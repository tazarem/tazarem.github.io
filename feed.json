{
    "version": "https://jsonfeed.org/version/1",
    "title": "Coding Coconut",
    "description": "주니어 웹 프론트엔드/백엔드 개발자. \\n  공부하는 것도, 노는 것도 그만큼 좋아합니다. \\n 현 직장에서는 AWS Lambda 와 Typscript 를 접목한 서드파티 모듈 개발을 하고 있습니다.",
    "home_page_url": "https://coding-coconut.com",
    "items": [
        {
            "id": "https://coding-coconut.com/post/cluwfj5n10001wc5o1tpd8c5d/",
            "url": "https://coding-coconut.com/post/cluwfj5n10001wc5o1tpd8c5d/",
            "title": "Docker 또는 Podman Container에서의 Selenium 웹 크롤링 Timed out 오류",
            "date_published": "2024-04-12T08:16:08.000Z",
            "content_html": "<p>이전에 selenium 프로젝트를 했다고 안일했었는지 크롤링 프로젝트를 만들고 배포하자마자 오류가 났다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Timed out receiving message from renderer: 600.000</span><br></pre></td></tr></table></figure>\n<p>원인이 뭔지 도통 모르겠어서 이것저것 찾아봤는데 결국 해결하긴 했음.</p>\n<h3 id=\"오류-고치는-과정\"><a href=\"#오류-고치는-과정\" class=\"headerlink\" title=\"오류 고치는 과정\"></a>오류 고치는 과정</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Ubuntu 20.04 LTS</span></span><br><span class=\"line\"><span class=\"comment\">// Podman Container Build</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 프로젝트 이미지 생성용 Dockerfile</span></span><br><span class=\"line\">FROM selenium/node-chrome:<span class=\"number\">123.0</span><span class=\"number\">.6312</span><span class=\"number\">.86</span>-chromedriver-<span class=\"number\">123.0</span><span class=\"number\">.6312</span><span class=\"number\">.86</span>-<span class=\"number\">20240402</span></span><br><span class=\"line\">(이후 Node.js 설치 과정)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 프로젝트 가동 후 셀레늄이 크롬을 띄우는 타이밍에서 타임아웃 메시지 확인</span></span><br><span class=\"line\">Timed out receiving message <span class=\"keyword\">from</span> renderer: <span class=\"number\">600.000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 혹여 버전이 서로 안맞나 싶어서 컨테이너 내부 sh명령어로 버전 확인</span></span><br><span class=\"line\">podman exec -it [프로젝트명] sh</span><br><span class=\"line\"></span><br><span class=\"line\">google-chrome --version</span><br><span class=\"line\">&gt; Google Chrome <span class=\"number\">123.0</span><span class=\"number\">.6312</span><span class=\"number\">.86</span> </span><br><span class=\"line\"></span><br><span class=\"line\">chromedriver --version</span><br><span class=\"line\">&gt; ChromeDriver <span class=\"number\">123.0</span><span class=\"number\">.6312</span><span class=\"number\">.86</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 버전도 맞고 컨테이너 내부에 구글 크롬이 안 깔린것도 아님을 확인</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 구글에 에러 검색/스택오버플로우 탐색. 아래 포스트는 오류 해결에 결정적이었다.</span></span><br><span class=\"line\"><span class=\"string\">&quot;https://stackoverflow.com/questions/48450594/selenium-timed-out-receiving-message-from-renderer?rq=2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 프로젝트에서 셀레늄이 크롬창을 띄우는 옵션 확인 (ts 기준)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> driver: WebDriver</span><br><span class=\"line\"><span class=\"keyword\">const</span> cOption = <span class=\"keyword\">new</span> chrome.Options()</span><br><span class=\"line\">cOption.addArguments(<span class=\"string\">&quot;--no-sandbox&quot;</span>)</span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--headless&quot;</span>) <span class=\"comment\">// 인터넷창 안띄우는 옵션 추가</span></span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--enable-automation&quot;</span>) <span class=\"comment\">//오토메이션 켜기</span></span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--disable-infobars&quot;</span>) <span class=\"comment\">//비활성화 옵션 추가</span></span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--start-maximized&quot;</span>) <span class=\"comment\">// 창을 최대로 키우기</span></span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--disable-dev-shm-usage&quot;</span>)</span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--single-process&quot;</span>)</span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--incognito&quot;</span>) <span class=\"comment\">//시크릿 모드</span></span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--log-level=off&quot;</span>)</span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--disk-cache-size=zero&quot;</span>)</span><br><span class=\"line\">.addArguments(<span class=\"string\">&quot;--disable-gpu&quot;</span>) <span class=\"comment\">// 이것 켜기(로컬에서 이 옵션을 킨 채로 가동하면 오류남)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 이후 빌드 후 배포했을 때 정상 가동 되었음을 확인함.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"추가\"><a href=\"#추가\" class=\"headerlink\" title=\"추가\"></a>추가</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--headless // 실제로 웹 창을 띄움. 페이지에 따라 돔을 못 읽어오기도 함. 우분투처럼 화면이 없는 OS에 배포할 때 이 옵션을 주석처리하면 DevPorts를 찾을 수 없다면서 오류가 떨어짐(송출할 수 있는 화면이 없기 때문)</span><br><span class=\"line\">--disable-gpu // gpu 비활성화 로컬 컴퓨터에서 이 옵션을 켜고 가동할 경우 커넥팅할수 없다는 오류가 나타남</span><br></pre></td></tr></table></figure>\n\n<p>골머리를 좀 많이 앓았는데 그냥 환경 옵션 추가로 해결되었다.</p>\n<p>ㅡㅡ;; 오류가 좀더 자세했으면 한다. 셀레늄이 문서화가 많이 안 되어있는 듯.</p>\n",
            "tags": [
                "cluster",
                "docker",
                "podman",
                "pm2",
                "ubuntu",
                "selenium",
                "chrome",
                "web_crawling",
                "문제해결",
                "이슈",
                "error"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nc000vwc5o5bce5jdi/",
            "url": "https://coding-coconut.com/post/cluwfj5nc000vwc5o5bce5jdi/",
            "title": "podman 컨테이너 내부 pm2 강제 종료 현상",
            "date_published": "2023-05-19T07:18:52.000Z",
            "content_html": "<p>podman 컨테이너가 자꾸 강제 종료되길래 컨테이너를 재가동하고 로그를 찍어봤다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 컨테이너 가동</span></span><br><span class=\"line\">podman start [컨테이너 명]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 가동중인 컨테이너 확인</span></span><br><span class=\"line\">podman ps</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 컨테이너 내부의 로그를 확인</span></span><br><span class=\"line\">podman <span class=\"built_in\">log</span> [컨테이너 명]</span><br></pre></td></tr></table></figure>\n\n\n<p>콘솔 확인 결과, 아래의 스택오버플로우 포스트처럼 pm2에서 코드 0 으로 종료된다는 문구가 출력됐다.</p>\n<p><a href=\"https://stackoverflow.com/questions/58947629/node-js-pm2-log-app-server0-exited-with-code-0-via-signal-sigkill\">https://stackoverflow.com/questions/58947629/node-js-pm2-log-app-server0-exited-with-code-0-via-signal-sigkill</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[RSS]Time 60min Call Complete.</span><br><span class=\"line\">RSS Timer::60 call complete.</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  generation_event: <span class=\"string\">&#x27;sitemap&#x27;</span>,</span><br><span class=\"line\">  origin_commander: <span class=\"string\">&#x27;timer&#x27;</span>,</span><br><span class=\"line\">  is_timer: 30</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[Sitemap]Time 30min Call Complete.</span><br><span class=\"line\">Sitemap Timer::30 call complete.</span><br><span class=\"line\">2023-05-18T05:59:41: PM2 <span class=\"built_in\">log</span>: App name:app id:0 disconnected</span><br><span class=\"line\">2023-05-18T05:59:41: PM2 <span class=\"built_in\">log</span>: App [app:0] exited with code [0] via signal [SIGTERM]</span><br><span class=\"line\">2023-05-18T05:59:41: PM2 error: Error caught <span class=\"keyword\">while</span> calling pidusage</span><br><span class=\"line\">2023-05-18T05:59:41: PM2 error: Error: ESRCH: no such process, <span class=\"built_in\">read</span></span><br><span class=\"line\">2023-05-18T05:59:41: PM2 error: Error caught <span class=\"keyword\">while</span> calling pidusage</span><br><span class=\"line\">2023-05-18T05:59:41: PM2 error: Error: ESRCH: no such process, <span class=\"built_in\">read</span></span><br><span class=\"line\">2023-05-18T05:59:41: PM2 error: 0 : id unknown</span><br><span class=\"line\">2023-05-18T05:59:41: PM2 error: Trace: Error: 0 : id unknown</span><br><span class=\"line\">    at God.logAndGenerateError (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/lib/God/Methods.js:39:12)</span><br><span class=\"line\">    at God.stopProcessId (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/lib/God/ActionMethods.js:289:21)</span><br><span class=\"line\">    at God.deleteProcessId (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/lib/God/ActionMethods.js:366:9)</span><br><span class=\"line\">    at Server.onmessage (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/node_modules/pm2-axon-rpc/lib/server.js:104:6)</span><br><span class=\"line\">    at RepSocket.emit (node:events:513:28)</span><br><span class=\"line\">    at RepSocket.emit (node:domain:489:12)</span><br><span class=\"line\">    at Parser.&lt;anonymous&gt; (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/node_modules/pm2-axon/lib/sockets/rep.js:51:15)</span><br><span class=\"line\">    at Parser.emit (node:events:513:28)</span><br><span class=\"line\">    at Parser.emit (node:domain:489:12)</span><br><span class=\"line\">    at Parser._write (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/node_modules/amp/lib/stream.js:91:16)</span><br><span class=\"line\">    at God.logAndGenerateError (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/lib/God/Methods.js:34:15)</span><br><span class=\"line\">    at /usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/lib/God/ActionMethods.js:367:30</span><br><span class=\"line\">    at God.stopProcessId (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/lib/God/ActionMethods.js:289:14)</span><br><span class=\"line\">    at God.deleteProcessId (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/lib/God/ActionMethods.js:366:9)</span><br><span class=\"line\">    at Server.onmessage (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/node_modules/pm2-axon-rpc/lib/server.js:104:6)</span><br><span class=\"line\">    at RepSocket.emit (node:events:513:28)</span><br><span class=\"line\">    at RepSocket.emit (node:domain:489:12)</span><br><span class=\"line\">    at Parser.&lt;anonymous&gt; (/usr/<span class=\"built_in\">local</span>/lib/node_modules/pm2/node_modules/pm2-axon/lib/sockets/rep.js:51:15)</span><br><span class=\"line\">    at Parser.emit (node:events:513:28)</span><br><span class=\"line\">    at Parser.emit (node:domain:489:12)</span><br><span class=\"line\">2023-05-18T05:59:41: PM2 <span class=\"built_in\">log</span>: PM2 successfully stopped</span><br></pre></td></tr></table></figure>\n\n<p>컨테이너 위에서 돌아가고 있는 프로그램은 Express API 서버였고, 스케쥴러처럼 특정 시간대에 트리거를 하는 로직을 수행하고 있었다.</p>\n<p>동일한 작동 방식으로 짜인 다른 컨테이너도 해당 오류가 일어나지 않았는데 왜 이 컨테이너만 이런 문제가 일어났을까?</p>\n<p>컨테이너의 Express 서버는 AWS의 Lambda를 호출하고 있었는데, 이 Lambda는 파일 생성이라는 다소 무거운 작업을 수행한다.</p>\n<ul>\n<li>axios 요청에서 타임아웃을 내지 않더라도, 요청 시간이 너무 길어지면 프로세스가 죽은 것임으로 간주하고 pm2가 강제 종료를 수행한다.</li>\n</ul>\n<p>해당 내역때문에 lamdba의 헤비한 로직을 비동기로 처리하고, 응답을 먼저 돌려주는 방식으로 바꾸었다.</p>\n",
            "tags": [
                "cluster",
                "podman",
                "pm2",
                "이슈",
                "문제"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nc000twc5oblyx86po/",
            "url": "https://coding-coconut.com/post/cluwfj5nc000twc5oblyx86po/",
            "title": "Ubuntu 20.10 이하 버전에서 podman 설치하기",
            "date_published": "2023-04-26T08:25:10.000Z",
            "content_html": "<h1 id=\"ubuntu-20-10-이하-버전에서-podman-설치하기\"><a href=\"#ubuntu-20-10-이하-버전에서-podman-설치하기\" class=\"headerlink\" title=\"ubuntu 20.10 이하 버전에서 podman 설치하기\"></a>ubuntu 20.10 이하 버전에서 podman 설치하기</h1><p>배포기준 AWS EC2 <code>Ubuntu 20.04 LTS</code> 에 설치하였다.</p>\n<h3 id=\"1-쿠빅-리포지토리-추가\"><a href=\"#1-쿠빅-리포지토리-추가\" class=\"headerlink\" title=\"1. 쿠빅 리포지토리 추가\"></a>1. 쿠빅 리포지토리 추가</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo sh -c <span class=\"string\">&quot;echo &#x27;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/ /&#x27; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>입력하고 커맨드해도 아무것도 출력되지 않는데 정상적으로 추가된 것이다.</p>\n</blockquote>\n<h3 id=\"2-리포지토리-키-추가\"><a href=\"#2-리포지토리-키-추가\" class=\"headerlink\" title=\"2. 리포지토리 키 추가\"></a>2. 리포지토리 키 추가</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/xUbuntu_20.04/Release.key -O- | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>OK 가 뜨면 성공</p>\n</blockquote>\n<h3 id=\"3-쿠빅-리포-추가-후-apt-업데이트\"><a href=\"#3-쿠빅-리포-추가-후-apt-업데이트\" class=\"headerlink\" title=\"3. 쿠빅 리포 추가 후 apt 업데이트\"></a>3. 쿠빅 리포 추가 후 apt 업데이트</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-포드맨-설치\"><a href=\"#4-포드맨-설치\" class=\"headerlink\" title=\"4. 포드맨 설치\"></a>4. 포드맨 설치</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt -y install podman</span><br></pre></td></tr></table></figure>\n\n<p>4번 과정까지 마치고 나면 커맨드에서 podman 을 인식할 수 있게 된다.</p>\n",
            "tags": [
                "podman",
                "ubuntu",
                "배포"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5n40006wc5og8324geb/",
            "url": "https://coding-coconut.com/post/cluwfj5n40006wc5og8324geb/",
            "title": "EC2에 도메인 바인딩하기",
            "date_published": "2023-04-19T02:41:06.000Z",
            "content_html": "<h2 id=\"도메인-로드밸런서-대상그룹-보안규칙-EC2-설정하기\"><a href=\"#도메인-로드밸런서-대상그룹-보안규칙-EC2-설정하기\" class=\"headerlink\" title=\"도메인-로드밸런서-대상그룹-보안규칙-EC2 설정하기\"></a>도메인-로드밸런서-대상그룹-보안규칙-EC2 설정하기</h2><blockquote>\n<p>도메인 접근 -&gt; 내부 포트 접근<br>80|443 -&gt; 8102</p>\n</blockquote>\n<ul>\n<li>접근 가능 VPC 일치에 주의</li>\n</ul>\n<ol>\n<li>EC2인스턴스에 보안그룹 추가하여 포트번호 뜷기 (예: 8102)</li>\n<li>대상그룹의 포트를 EC2인스턴스의 포트번호와 일치시키기 인스턴스:8102 대상그룹:8102(HTTP)</li>\n<li>생성한 대상그룹에 대상 등록으로 EC2인스턴스 바인딩</li>\n<li>대상그룹에 등록된 EC2인스턴스의 헬스체크를 기다리기</li>\n<li>로드밸런서 생성하기</li>\n<li>가용 영역 선택, 생성과정 중 만들어놓은 대상그룹 바인딩시키기</li>\n<li>보안그룹은 웹 전용으로 하기(80,443을 뜷는 보안그룹)</li>\n<li>리스너에서 HTTPS 443 추가, 인증서 선택하기</li>\n<li>기존에 묶인 80리스너를 443리디렉션에 301 응답으로 바꾸기</li>\n</ol>\n",
            "tags": [
                "aws",
                "배포"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nk0040wc5o3mfzbphl/",
            "url": "https://coding-coconut.com/post/cluwfj5nk0040wc5o3mfzbphl/",
            "title": "굶지마 캐릭터 모드 만드는 과정 정리",
            "date_published": "2023-01-15T07:19:15.000Z",
            "content_html": "<h1 id=\"굶지마-캐릭터-모드-만드는-과정-정리\"><a href=\"#굶지마-캐릭터-모드-만드는-과정-정리\" class=\"headerlink\" title=\"굶지마 캐릭터 모드 만드는 과정 정리\"></a>굶지마 캐릭터 모드 만드는 과정 정리</h1><blockquote>\n<p><a href=\"https://forums.kleientertainment.com/forums/topic/28021-getting-started-guides-tutorials-and-examples/\">참조 : 클레이 포럼 모딩 종합 튜토리얼</a></p>\n</blockquote>\n<h3 id=\"1-캐릭터-샘플-다운받기\"><a href=\"#1-캐릭터-샘플-다운받기\" class=\"headerlink\" title=\"1.캐릭터 샘플 다운받기\"></a>1.캐릭터 샘플 다운받기</h3><p>굶지마 캐릭터 빌드 템플릿을 다운받아 준다.</p>\n<blockquote>\n<p>Deowolf의 extended character template 다운로드 받기</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/DragonWolfLeo/extendedsamplecharacter-dontstarvetogether\">깃허브</a></li>\n<li><a href=\"https://forums.kleientertainment.com/files/file/950-extended-sample-character/\">굶지마 포럼</a></li>\n</ul>\n<p>둘 다 동일한 파일이니 버전만 잘 확인하면 된다. 굶지마 포럼의 경우 다운받는데 클레이 로그인이 필요할 수 있다.</p>\n<p>포럼에는 튜토리얼 영상도 있으니 참조.</p>\n<br/>\n\n<h3 id=\"2-vsCode-또는-Notepad-로-이름-바꾸기-대소문자-구분\"><a href=\"#2-vsCode-또는-Notepad-로-이름-바꾸기-대소문자-구분\" class=\"headerlink\" title=\"2.vsCode 또는 Notepad++로 이름 바꾸기(대소문자 구분)\"></a>2.vsCode 또는 Notepad++로 이름 바꾸기(대소문자 구분)</h3><ul>\n<li><a href=\"https://code.visualstudio.com/\">vsCode</a></li>\n<li><a href=\"https://notepad-plus-plus.org/downloads/\">Notepad++</a></li>\n</ul>\n<ol>\n<li><p>다운받은 프로젝트 파일의 폴더명으로 압축을 푼다.</p>\n</li>\n<li><p>vsCode 또는 Notepad++ 처럼 전체파일 내부의 텍스트 바꾸기와 같은 특수한 기능이 있는 코드 편집기로 프로젝트 폴더를 연다.</p>\n</li>\n</ol>\n<p><img src=\"/img/postimg2/project_open.png\" alt=\"프로젝트 열기\"></p>\n<ol start=\"3\">\n<li>대소문자 구분에 유의하여 캐릭터의 이름을 수정해준다. ( ctrl + f 키를 누르면 탐색 창이 열린다. )</li>\n</ol>\n<p>*샘플 캐릭터의 이름은 esctemplate로, <b>반드시 대소문자를 구분</b>하여 바꾸려는 캐릭터의 이름으로 바꿔준다.</p>\n<p><img src=\"/img/postimg2/save_as_project_othername.png\" alt=\"이름 바꾸기(소문자)\"><br><img src=\"/img/postimg2/save_as_project_othername2.png\" alt=\"이름 바꾸기(대문자)\"></p>\n<blockquote>\n<p>esctemplate, ESCTEMPLATE =&gt; 바꾸려는 캐릭터 소문자명, 바꾸려는 캐릭터 대문자명</p>\n</blockquote>\n<p>.lua 내부 파일들은 물론이고, exported안에 있는 프리팹 폴더명과 .scml파일, .png파일의 이름들도 수정해주어야한다.</p>\n<p>.xml 파일은 지우게 되니 신경쓰지 않아도 상관없다.</p>\n<p><img src=\"/img/postimg2/save_as_project_othername3.png\" alt=\"이름 바꾸기(대문자)\"></p>\n<p>👉 클레이 포럼 외부 링크: <a href=\"https://forums.kleientertainment.com/forums/topic/73055-font-what-is-the-font-for-together/?do=findComment&comment=855020\">캐릭터 초상화의 이름을 수정할 수 있는 굶지마 폰트(이미지)</a></p>\n<br/>\n\n<h3 id=\"3-exported-images-의-png-파일-편집하기\"><a href=\"#3-exported-images-의-png-파일-편집하기\" class=\"headerlink\" title=\"3.exported, images 의 png 파일 편집하기\"></a>3.exported, images 의 png 파일 편집하기</h3><p>프로젝트 폴더의 exported와 images 폴더 안에 있는 png들을 모드캐릭터에 맞게 이미지를 수정해준다.</p>\n<p>*png파일의 픽셀 크기 및 해상도는 건드리지 않는 것이 모드 템플릿에 권고되어있다.</p>\n<p>굶지마 애니메이션 빌드 파일을 만들기가 까다롭기 때문이다..</p>\n<blockquote>\n<p>png이미지를 바꾼 건 좋은데, 바꾼 이미지가 비뚤어지지 않았는지 어떻게 확인할까?</p>\n</blockquote>\n<p><img src=\"/img/postimg2/mod_tools2.png\" alt=\"굶지마 모드 툴\"></p>\n<p>스팀을 켜고, 라이브러리에 들어가서 검색 탭 바로 위쪽에 있는 필터링 바를 클릭해준다.</p>\n<p><img src=\"/img/postimg2/mod_tools.png\" alt=\"굶지마 모드 툴\"></p>\n<p>Don’t starve mod tools 프로그램이 보일텐데, 미설치인 경우 설치해주자.</p>\n<p><img src=\"/img/postimg2/mod_tools3.png\" alt=\"굶지마 모드 툴\"></p>\n<p>Mod tools를 우클릭하여 실행하면, 위와 같은 창이 뜬다.</p>\n<p>Launch Spriter를 체크하고 실행한다.</p>\n<p><img src=\"/img/postimg2/show_spriter0.png\" alt=\"굶지마 모드 툴\"></p>\n<p>File &gt; Open Project 로 캐릭터 exported 폴더에 있는 .scml 파일을 다음처럼 열어볼 수 있다.</p>\n<p><img src=\"/img/postimg2/show_spriter.png\" alt=\"굶지마 모드 툴\"></p>\n<p>.scml은 게임을 켜지 않고도 캐릭터의 모습을 미리 볼 수 있게 해준다.</p>\n<blockquote>\n<p>*주의: png 파일만 편집. scml은 새로 저장하거나 건드리지 않기.</p>\n</blockquote>\n<p>모습이 잘 적용된 것 같다면 <b>.scml을 저장하지 말고</b> 4번으로 넘어가자.</p>\n<br/>\n\n<h3 id=\"4-anim폴더-내부-xml-tex-파일-지우고-로컬-mods-폴더-안에-복사-붙여넣기\"><a href=\"#4-anim폴더-내부-xml-tex-파일-지우고-로컬-mods-폴더-안에-복사-붙여넣기\" class=\"headerlink\" title=\"4 anim폴더 내부, .xml, .tex 파일 지우고 로컬 mods 폴더 안에 복사, 붙여넣기\"></a>4 anim폴더 내부, .xml, .tex 파일 지우고 로컬 mods 폴더 안에 복사, 붙여넣기</h3><p>굶지마는 압축된 .xml과 .tex 파일로 이미지를 불러온다.</p>\n<p>컴퓨터가 읽을 수 있는 파일로 변환시키기 위해 프로젝트 폴더 내부의<br>modicon(모드 아이콘)의 tex,xml. portraits(초상화)의 tex, xml. images 폴더 안에 있는 .tex와 .xml 파일들을 모두 제거해준다.<br>또한 컴파일러가 애니메이션 빌드를 다시 생성해야 하기 때문에, 캐릭터 모드 폴더 안에 있는 anim폴더 내부의 zip도 없애준다.</p>\n<blockquote>\n<p>anim폴더 내부의 zip이 없어야 컴파일러가 .scml을 다시 변환하고, xml파일이 없어야 tex파일과 xml파일을 생성한다.</p>\n</blockquote>\n<p><img src=\"/img/postimg2/remove_anim_tex_xml_etc.png\" alt=\"필요 없는 파일을 제거한 모습\"></p>\n<p>anim 폴더 안의 .zip파일들과 .tex와 .xml을 다 제거해주었다면, 다음 경로로 가서 폴더를 열어준다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#굶지마 투게더 모드폴더 경로</span><br><span class=\"line\">C:\\Program Files (x86)\\Steam\\steamapps\\common\\Don&#39;t Starve Together\\mods</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/postimg2/mods_folder.png\" alt=\"굶지마 모드 폴더\"></p>\n<p>로컬 모드를 적용시키기 위해<br>mods 폴더에다 여태껏 만든 프로젝트 폴더를 <b>드래그하지 말고</b>, 원본을 ctrl+c , ctrl+v 한다.</p>\n<p>굳이 드래그해서 옮기지 않는 이유는 원본을 보존하기 위함이다.</p>\n<p><img src=\"/img/postimg2/mods_folder2.png\" alt=\"굶지마 모드 폴더\"></p>\n<br/>\n\n<h3 id=\"5-Don’t-starve-게임을-켜서-컴파일러-작동시키기\"><a href=\"#5-Don’t-starve-게임을-켜서-컴파일러-작동시키기\" class=\"headerlink\" title=\"5.Don’t starve 게임을 켜서 컴파일러 작동시키기\"></a>5.Don’t starve 게임을 켜서 컴파일러 작동시키기</h3><p>Don’t starve mod tools 를 다운받은 이후 게임을 켜면,<br>까만 콘솔창이 뜨게 되는데 이는 컴파일러이다.</p>\n<p>컴파일러가 미변환 모드를 체크하고 .scml =&gt; .anim 또는 .zip으로, .png는 tex와 xml로 변환한다.</p>\n<p><img src=\"/img/postimg2/mods_compiler.png\" alt=\"굶지마 모드 폴더\"></p>\n<p>컴파일러가 저절로 꺼질 때까지 기다리면, 컴파일러가 변환을 완료하고 굶지마 게임이 자동으로 실행된다.</p>\n<p><img src=\"/img/postimg2/test_world_in_mod.png\" alt=\"인게임 확인\"></p>\n<p>게임이 켜진 김에 모드를 적용하고 월드를 생성해 본다.</p>\n<p><img src=\"/img/postimg2/test_world_in_mod2.png\" alt=\"인게임 확인\"></p>\n<p>여기까지 잘 따라왔다면 캐릭터의 초상화도 잘 나올 텐데, 정작 캐릭터의 이름이 보이질 않는다.</p>\n<br/>\n\n<h3 id=\"6-tex-파일-생성-확인\"><a href=\"#6-tex-파일-생성-확인\" class=\"headerlink\" title=\"6.tex 파일 생성 확인\"></a>6.tex 파일 생성 확인</h3><p>steam의 mods 폴더를 열고 만든 모드 폴더에 들어가보자.</p>\n<p>modicon을 제외하고 각 .png마다 tex와 xml 파일이 생성된 것을 확인할 수 있을 것이다.</p>\n<p><img src=\"/img/postimg2/tex_and_xml.png\" alt=\"tex와 xml생성 확인\"></p>\n<br/>\n\n<h3 id=\"7-캐릭터-이름-지정-xml-내부의-tex파일-지정-구문-수정하기\"><a href=\"#7-캐릭터-이름-지정-xml-내부의-tex파일-지정-구문-수정하기\" class=\"headerlink\" title=\"7.캐릭터 이름 지정 xml 내부의 tex파일 지정 구문 수정하기\"></a>7.캐릭터 이름 지정 xml 내부의 tex파일 지정 구문 수정하기</h3><p>파일도 정상적으로 생성되었는데, 왜 캐릭터의 이름이 보이지 않는 것일까?</p>\n<p>템플릿 파일을 주의깊게 봤다면 이름 png 옆에 조그맣게 안내문 txt 파일이 있는 것을 확인할 수 있다.</p>\n<p>내용을 읽어보면, xml 파일을 열어 tex이름을 지정하는 구문을 수정해주어야 이름 텍스트가 적용된다는 말이다.</p>\n<p>mods 폴더를 열고 만든 모드 폴더를 코드 에디터로 열어준다.</p>\n<p><img src=\"/img/postimg2/edit_name.png\" alt=\"names와 names_gold 파일 수정\"></p>\n<p>names와 names_gold.xml파일을 열고, 다음처럼 수정하고 저장한다.</p>\n<p><img src=\"/img/postimg2/edit_name2.png\" alt=\"names와 names_gold 파일 수정\"></p>\n<p>그리고 자동으로 tex와 xml을 생성하지 않는 modicon.png도 잠깐 images 폴더에 복사해 준다.</p>\n<p>컴파일러를 다시 실행시키면, modicon의 tex와 xml이 생성되는 걸 볼 수 있다.<br><img src=\"/img/postimg2/modicon_convert.png\" alt=\"모드아이콘 변환\"><br>변환된 모드아이콘은 tex, xml과 같이 modmain.lua가 있는 위치에 넣어주자.<br><br/></p>\n<h3 id=\"8-작동-확인\"><a href=\"#8-작동-확인\" class=\"headerlink\" title=\"8. 작동 확인\"></a>8. 작동 확인</h3><p><img src=\"/img/postimg2/test_world_in_mod3.png\" alt=\"초상화 이름텍스트 확인\"></p>\n<p>초상화와 이름도 잘 출력된다.</p>\n<p>인게임에서 테스트하며 모드가 잘 작동되는지 확인한다.</p>\n<p><img src=\"/img/postimg2/mod_example1.png\" alt=\"모드 동작 확인하기1\"><br><img src=\"/img/postimg2/mod_example2.png\" alt=\"모드 동작 확인하기2\"></p>\n<br/>\n\n<h2 id=\"그-외\"><a href=\"#그-외\" class=\"headerlink\" title=\"그 외\"></a>그 외</h2><h3 id=\"심화\"><a href=\"#심화\" class=\"headerlink\" title=\"심화\"></a>심화</h3><h4 id=\"손으로-들-수-있는-간단한-물건-만들기\"><a href=\"#손으로-들-수-있는-간단한-물건-만들기\" class=\"headerlink\" title=\"손으로 들 수 있는 간단한 물건 만들기\"></a>손으로 들 수 있는 간단한 물건 만들기</h4><blockquote>\n<p><a href=\"https://forums.kleientertainment.com/forums/topic/29427-tutorial-creating-a-handslot-equippable-item-from-scratch/\">클레이 포럼 링크 참조</a></p>\n</blockquote>\n<br/>\n\n<h4 id=\"캐릭터-자체음성-만들기\"><a href=\"#캐릭터-자체음성-만들기\" class=\"headerlink\" title=\"캐릭터 자체음성 만들기\"></a>캐릭터 자체음성 만들기</h4><blockquote>\n<p><a href=\"https://forums.kleientertainment.com/forums/topic/27803-tutorial-adding-custom-sound-to-your-custom-character/\">클레이 포럼 링크 참조</a></p>\n</blockquote>\n<br/>\n\n<h4 id=\"모드-업로드하는-법\"><a href=\"#모드-업로드하는-법\" class=\"headerlink\" title=\"모드 업로드하는 법\"></a>모드 업로드하는 법</h4><blockquote>\n<p>추후 게시 예정..</p>\n</blockquote>\n<br/>\n<br/>\n\n<h3 id=\"간단한-디버깅\"><a href=\"#간단한-디버깅\" class=\"headerlink\" title=\"간단한 디버깅\"></a>간단한 디버깅</h3><h4 id=\"로컬에서-모드-적용하기\"><a href=\"#로컬에서-모드-적용하기\" class=\"headerlink\" title=\"로컬에서 모드 적용하기\"></a>로컬에서 모드 적용하기</h4><p>만들어둔 모드 프로젝트 폴더를 mods 아래에 두고 게임을 실행한다.<br>프로젝트 폴더의 바로 아래에는 modmain.lua와 modicon.png 또는 tex가 있어야 한다.</p>\n<br/>\n\n<h4 id=\"모드-작동-시-어디서-오류가-나는지-보기\"><a href=\"#모드-작동-시-어디서-오류가-나는지-보기\" class=\"headerlink\" title=\"모드 작동 시 어디서 오류가 나는지 보기\"></a>모드 작동 시 어디서 오류가 나는지 보기</h4><p>기존 게임에서는 모드 오류 시 오류 메세지를 반환하고 그대로 게임이 멈추었으나, 모더가 아닌 일반 사용자들의 이용을 고려한 탓인지 오류 메세지를 master로그에 숨기고,<br>사용자들이 모드를 배제하고 게임을 플레이할 수 있도록 업데이트되었다.<br>덕분에 모드 디버깅이 좀 까다로워졌다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#투게더 로그파일 경로</span><br><span class=\"line\">C:\\Users\\user\\Documents\\Klei\\DoNotStarveTogether\\master_server_log</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>해당 파일에서 LUA ERROR 구문을 찾으면 된다. 무슨 오류이며 몇번째 줄에서 오류가 났는지 상세하다.</p>\n</blockquote>\n<p>모드 파일에 문제가 없다면 대부분 resolve path, 경로를 찾지 못하는 오류이다.<br>asset등에서 참조하는 경로에 오탈자가 있거나, 어느 한 구문을 빼먹었거나,<br>tex파일이 생성되지 않아서 파일을 찾을 수 없는 경우, 파일 누락 등이 원인이다.</p>\n<br/>\n\n<h4 id=\"아이템-소환하기\"><a href=\"#아이템-소환하기\" class=\"headerlink\" title=\"아이템 소환하기\"></a>아이템 소환하기</h4><p>모드로 만들어둔 아이템을 바로 테스트해보고싶을 수 있다.<br>아이템을 prefab으로 등록해두었다면 /c_give(“아이템 프리팹명”,갯수) 로 캐릭터 인벤토리에 들어오게 할 수 있다.</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#아이템 인벤토리에 넣기</span><br><span class=\"line\">c_give(&quot;cutgrass&quot;,<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#아이템 소환하기</span><br><span class=\"line\">c_spawn(&quot;twigs&quot;,3)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><a href=\"https://dontstarve.fandom.com/wiki/Console/Don%27t_Starve_Together_Commands\">참조링크: 굶지마 콘솔 커맨드 모음</a></p>\n</blockquote>\n<br/>\n\n<h2 id=\"해결되지-않은-이슈\"><a href=\"#해결되지-않은-이슈\" class=\"headerlink\" title=\"해결되지 않은 이슈\"></a>해결되지 않은 이슈</h2><h4 id=\"Together-saveslot-초상화에-대한-이슈\"><a href=\"#Together-saveslot-초상화에-대한-이슈\" class=\"headerlink\" title=\"Together: saveslot 초상화에 대한 이슈\"></a>Together: saveslot 초상화에 대한 이슈</h4><ul>\n<li>서버 리스트를 뿌려주는 화면에서 모드를 불러오지 못하기 때문에, 세이브파일 캐릭터 초상화에 항상 종이 윌슨이 그려지는 이슈. 포럼에서도 해결하기 까다로운 문제인 듯.</li>\n</ul>\n<h4 id=\"dyn-파일에-관한-것\"><a href=\"#dyn-파일에-관한-것\" class=\"headerlink\" title=\".dyn 파일에 관한 것\"></a>.dyn 파일에 관한 것</h4><ul>\n<li>워톡스 등 클레이가 유료로 판매하는 아이템 또는 캐릭터의 애니메이션이 들어있는 파일이다. 이는 상업적 이용과도 연관되어 있다. 공식에서도 뜯지 말라고 하고, 무엇보다 암호화되어있다.</li>\n</ul>\n",
            "tags": [
                "dontstarve",
                "modding"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5n8000bwc5oclgqbxld/",
            "url": "https://coding-coconut.com/post/cluwfj5n8000bwc5oclgqbxld/",
            "title": "Hexo tag 영문태그 대소문자 수정 시 반영되지 않는 오류",
            "date_published": "2022-08-25T03:35:55.000Z",
            "content_html": "<p>태그 영문 대소문자를 수정했을 때 링크 오류가 발생했다</p>\n<p>원인은 github에서 영문대소문자 수정 시 커밋사항에 반영되지 않기 때문이다.<br>태그를 아예 다른 문자로 수정하고 hexo deploy 로 재배포하면 된다.</p>\n<p>참조 링크<br><a href=\"https://github.com/hexojs/hexo/issues/2600\">https://github.com/hexojs/hexo/issues/2600</a></p>\n",
            "tags": [
                "error",
                "hexo"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nb000rwc5og5ya8dir/",
            "url": "https://coding-coconut.com/post/cluwfj5nb000rwc5og5ya8dir/",
            "title": "Linux 서버에서 https 인증과 Apache2 프록시패스 설정하기",
            "date_published": "2022-08-24T09:14:09.000Z",
            "content_html": "<h3 id=\"들어가며\"><a href=\"#들어가며\" class=\"headerlink\" title=\"들어가며\"></a>들어가며</h3><p>인증서 발급방법은 기존에 알고있어서 문제가 되지 않았는데 아파치 설정파일 만지는 법을 까먹어서 한동안 설정파일과 씨름했다.. -.-;;<br>로그인한 유저가 관리자 권한일 경우 굳이 sudo를 입력하지 않아도 된다!</p>\n<h3 id=\"0-apache2-를-깔려면-apt를-사용해야-하므로-업데이트가-필요\"><a href=\"#0-apache2-를-깔려면-apt를-사용해야-하므로-업데이트가-필요\" class=\"headerlink\" title=\"0. apache2 를 깔려면 apt를 사용해야 하므로 업데이트가 필요\"></a>0. apache2 를 깔려면 apt를 사용해야 하므로 업데이트가 필요</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-linux-전용-apache2-설치\"><a href=\"#1-linux-전용-apache2-설치\" class=\"headerlink\" title=\"1. linux 전용 apache2 설치\"></a>1. linux 전용 apache2 설치</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install apache2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-000-default-conf-편집\"><a href=\"#2-000-default-conf-편집\" class=\"headerlink\" title=\"2. 000-default.conf 편집\"></a>2. 000-default.conf 편집</h3><p>위치는 리눅스 우분투 서버18 기준 맨~ 위 디렉토리 /etc/apache2/site-available/000-default.conf 이다<br>vi 로 편집하거나 (apache2 를 처음 설치하게 되면 기본으로 파일설정 권한이 읽기전용이다 -.-;;;)</p>\n<blockquote>\n<p>파일 권한 수정(읽기 쓰기 실행 다 허용)</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo chmod 777 000-default.conf[혹은 디렉토리]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>000-default.conf 를 아래처럼 편집한 후 저장<br>vi 명령어를 사용해서 즉석으로 편집해도 되고 파일질라같은 ftp 응용프로그램을 이용해서 로컬에서 작성하고 덮어쓰기해도 좋다.<br>vi 명령어일 경우 저장하고 나가기는 esc + :wq!이다</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#LoadModule 구문을 써 줘야 ProxyPass가 작동한다. 이거 미리 설정하면 아래 파일을 실행시키는 스크립트 작성할 필요 x</span></span><br><span class=\"line\">LoadModule proxy_module modules/mod_proxy.so</span><br><span class=\"line\">LoadModule proxy_http_module modules/mod_proxy_http.so</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;VirtualHost *:80&gt;</span><br><span class=\"line\">\tServerAdmin webmaster@localhost</span><br><span class=\"line\">\tDocumentRoot /var/www/html</span><br><span class=\"line\"></span><br><span class=\"line\">\tServerName yourdomain.com</span><br><span class=\"line\">\tServerAlias yourdomain.com</span><br><span class=\"line\"></span><br><span class=\"line\">\tProxyRequests Off</span><br><span class=\"line\">\tProxyPreserveHost On</span><br><span class=\"line\">    <span class=\"comment\"># 80으로 받으면 아래 주소로 넘긴다. 여기서의 로컬호스트는 apache가 돌아가는 컴퓨터의 로컬호스트.</span></span><br><span class=\"line\">\t<span class=\"comment\">#주소창에서 보여지는 주소도 서버네임으로 바뀌어서 보여진다.</span></span><br><span class=\"line\">  \tProxyPass / http://localhost:8080/</span><br><span class=\"line\">  \tProxyPassReverse / http://localhost:8080/</span><br><span class=\"line\"></span><br><span class=\"line\">\tErrorLog <span class=\"variable\">$&#123;APACHE_LOG_DIR&#125;</span>/error.log</span><br><span class=\"line\">\tCustomLog <span class=\"variable\">$&#123;APACHE_LOG_DIR&#125;</span>/access.log combined</span><br><span class=\"line\"></span><br><span class=\"line\">    RewriteEngine on</span><br><span class=\"line\">    RewriteCond %&#123;SERVER_NAME&#125; =content-ad-dev.fastview.co.kr</span><br><span class=\"line\">    RewriteRule ^ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [END,NE,R=permanent]</span><br><span class=\"line\">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-Apache2-서비스-재가동\"><a href=\"#3-Apache2-서비스-재가동\" class=\"headerlink\" title=\"3. Apache2 서비스 재가동\"></a>3. Apache2 서비스 재가동</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service apache2 restart</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-Snap-설치-이미-깔려-있으면-생략\"><a href=\"#4-Snap-설치-이미-깔려-있으면-생략\" class=\"headerlink\" title=\"4. Snap 설치(이미 깔려 있으면 생략)\"></a>4. Snap 설치(이미 깔려 있으면 생략)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo snap install core; sudo snap refresh core</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-Snap으로-Certbot-설치\"><a href=\"#5-Snap으로-Certbot-설치\" class=\"headerlink\" title=\"5. Snap으로 Certbot 설치\"></a>5. Snap으로 Certbot 설치</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo snap install --classic certbot</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-Apache-사양으로-인증서-발급-apache2-서비스가-가동-중이고-80포트가-뜷려있어야-함\"><a href=\"#6-Apache-사양으로-인증서-발급-apache2-서비스가-가동-중이고-80포트가-뜷려있어야-함\" class=\"headerlink\" title=\"6. Apache 사양으로 인증서 발급(apache2 서비스가 가동 중이고 80포트가 뜷려있어야 함)\"></a>6. Apache 사양으로 인증서 발급(apache2 서비스가 가동 중이고 80포트가 뜷려있어야 함)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo certbot --apache</span><br></pre></td></tr></table></figure>\n<p>머라머라 나오는데 읽어보면 도메인 입력해달라는것과 인증서 만료 시 발송할 이메일좀 설정해달라는 내용<br>그리고.. 뭔가를 보낸다는 내용인데 이 항목은 생략해도 됨</p>\n<p>만약 과정이 꼬여서 000-default.conf를 다시 수정해야 하면, 인증서파일 재설정을 하면 된다.</p>\n<p>인증서가 이미 존재할 때 위 명령어를 입력하면 인증서 목록이 뜨는데 원하는 도메인의 번호를 입력한다.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1: Attempt to reinstall this existing certificate</span><br></pre></td></tr></table></figure>\n\n<p>해당 항목을 선택하면 Certbot의 인증서 파일(000-default-le-ssl.conf)이 다시 갱신된다.</p>\n<h3 id=\"7-확인\"><a href=\"#7-확인\" class=\"headerlink\" title=\"7. 확인\"></a>7. 확인</h3><p>웹페이지에 접속해서 자물쇠 표시가 뜨면 성공!</p>\n",
            "tags": [
                "certbot",
                "배포",
                "https",
                "인증서",
                "apache"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5n9000dwc5ocza98o5q/",
            "url": "https://coding-coconut.com/post/cluwfj5n9000dwc5ocza98o5q/",
            "title": "Hexo 배포 커맨드와 커스텀 도메인에 관한 이슈",
            "date_published": "2022-07-28T00:56:12.000Z",
            "content_html": "<h3 id=\"문제점\"><a href=\"#문제점\" class=\"headerlink\" title=\"문제점\"></a>문제점</h3><p> 기존 도메인에서 블로그 전용 도메인을 구매하고, 깃허브 페이지에 연결해 놓았었는데<br>Hexo로 만든 블로그 프로젝트에서 <code>hexo deploy</code> 커맨드를 이용해 배포하면<br>깃허브 페이지의 퍼블리싱된 커스텀 도메인이 초기화가 되는 이슈가 발생했다.</p>\n<h3 id=\"해결\"><a href=\"#해결\" class=\"headerlink\" title=\"해결\"></a>해결</h3><p>이를 해결하려면 hexo 의 블로그 프로젝트 source 폴더에<br>CNAME 파일을 생성하고, 안에 퍼블리싱할 커스텀 도메인을 입력한다.</p>\n<p><img src=\"/img/postimg/cname_file.png\" alt=\"cname_file\"></p>\n<p>이후 <code>hexo deploy</code> 커맨드를 입력하여 배포해도 깃허브 페이지의 커스텀 도메인이 해제되지 않는다.</p>\n",
            "tags": [
                "배포",
                "github_page",
                "hexo",
                "issue",
                "custom_domain",
                "hexo_deploy"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5n50008wc5o8zrq0iq0/",
            "url": "https://coding-coconut.com/post/cluwfj5n50008wc5o8zrq0iq0/",
            "title": "Github Page에 커스텀 도메인 연결하기",
            "date_published": "2022-07-21T08:20:52.000Z",
            "content_html": "<h1 id=\"Github-Page에-커스텀-도메인-연결하기\"><a href=\"#Github-Page에-커스텀-도메인-연결하기\" class=\"headerlink\" title=\"Github Page에 커스텀 도메인 연결하기\"></a>Github Page에 커스텀 도메인 연결하기</h1><p>방법은 다음과 같다.</p>\n<h3 id=\"도메인을-구입한-사이트에서-깃허브-리포지토리-주소를-CNAME으로-추가-또는-변경해주기\"><a href=\"#도메인을-구입한-사이트에서-깃허브-리포지토리-주소를-CNAME으로-추가-또는-변경해주기\" class=\"headerlink\" title=\"도메인을 구입한 사이트에서 깃허브 리포지토리 주소를 CNAME으로 추가 또는 변경해주기\"></a>도메인을 구입한 사이트에서 깃허브 리포지토리 주소를 CNAME으로 추가 또는 변경해주기</h3><p>도메인을 구입한 사이트에서 있어야 할 레코드는 다음과 같다.</p>\n<table>\n<thead>\n<tr>\n<th>레코드명</th>\n<th>이름</th>\n<th>데이터</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CNAME</td>\n<td>www</td>\n<td>[yourRepo].github.io</td>\n</tr>\n<tr>\n<td>A</td>\n<td>@</td>\n<td>185.199.108.153</td>\n</tr>\n<tr>\n<td>A</td>\n<td>@</td>\n<td>185.199.109.153</td>\n</tr>\n<tr>\n<td>A</td>\n<td>@</td>\n<td>185.199.110.153</td>\n</tr>\n<tr>\n<td>A</td>\n<td>@</td>\n<td>185.199.111.153</td>\n</tr>\n</tbody></table>\n<p>네임서버는 따로 이관하지 않아도 된다.</p>\n<h3 id=\"블로그로-서비스되고있는-깃허브-페이지의-리포지토리-gt-Setting-gt-Page\"><a href=\"#블로그로-서비스되고있는-깃허브-페이지의-리포지토리-gt-Setting-gt-Page\" class=\"headerlink\" title=\"블로그로 서비스되고있는 깃허브 페이지의 리포지토리 =&gt; Setting =&gt; Page\"></a>블로그로 서비스되고있는 깃허브 페이지의 리포지토리 =&gt; Setting =&gt; Page</h3><p><img src=\"/img/postimg/custom_domain.png\" alt=\"커스텀 도메인\"></p>\n<p>save를 누르면 위에 등록한 DNS정보가 모두 올바를 경우 해당 주소로 퍼블리시되었다는 알람을 띄운다.</p>\n<p>아래 체크박스를 보면 알 수 있지만 GithubPage 특성상 https 옵션을 활성화할 수 있다.</p>\n<p>도메인으로 접속했을 때 깃허브 페이지가 뜨면 성공!</p>\n",
            "tags": [
                "dns",
                "github_page",
                "domain"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5n9000fwc5ob9wsgukh/",
            "url": "https://coding-coconut.com/post/cluwfj5n9000fwc5ob9wsgukh/",
            "title": "Hexo 테마 만들기",
            "date_published": "2022-06-10T08:03:21.000Z",
            "content_html": "<h1 id=\"Hexo-테마-구축하기\"><a href=\"#Hexo-테마-구축하기\" class=\"headerlink\" title=\"Hexo 테마 구축하기\"></a>Hexo 테마 구축하기</h1><h4 id=\"들어가며\"><a href=\"#들어가며\" class=\"headerlink\" title=\"들어가며\"></a>들어가며</h4><p>Hexo 에서 기본적으로 제공하는 기본값 레이아웃 icarus의 소스가 많이 도움이 되었다.<br><br>Hexo 는 블로그 ‘프레임워크’ 이며, 공식 문서에서는 helper라는 이름으로 렌더링 스크립트도 제공한다. 용어가 생소해서 많이 헤맸던 기억이 난다.<br>헬퍼에서 제공하는 스크립트는 서버사이드 혹은 클라이언트 사이드 렌더링처럼 뷰 엔진 파일 위에서 사용할 수 있다. 해외에서 안내하는 방법대로 테마를 만들어보고, 정리해보고자 이렇게 게시물을 작성하게 되었다.<br></p>\n<h3 id=\"목차\"><a href=\"#목차\" class=\"headerlink\" title=\"목차\"></a>목차</h3><ul>\n<li>테마 폴더 만들기</li>\n<li>layout 파일 만들기</li>\n<li>기본 페이지 추가하기<ul>\n<li>index</li>\n<li>archive</li>\n</ul>\n</li>\n<li>부분 렌더링(페이지 쪼개기)</li>\n<li>정적 소스 불러오기</li>\n<li>만든 테마 적용하기</li>\n<li>테마가 적용된 블로그 배포하기</li>\n<li>테마 만들기 심화<ul>\n<li>부가 페이지 만들기</li>\n<li>댓글 위젯 달기(utterances)</li>\n<li>손수 위젯 만들기</li>\n<li>커스텀 404 페이지(github)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"테마-폴더-만들기\"><a href=\"#테마-폴더-만들기\" class=\"headerlink\" title=\"테마 폴더 만들기\"></a>테마 폴더 만들기</h2><p>Hexo init을 실행하고 나서, 프로젝트의 루트 경로 아래에 themes 폴더를 만든다.</p>\n<p>themes 폴더 하위에 테마 이름을 짓고 영문명으로 폴더를 생성한다. ex)your-theme-name</p>\n<p>your-theme-name 폴더 하위에도 _config.yml 파일을 만든다.</p>\n<blockquote>\n<p>Hexo는 _config.yml을 환경변수 겸용 클라이언트딴 전역변수처럼 사용할 수 있는데, <br><br>테마 하위에 있는 _config.yml은 이 테마에서만 특별하게 적용되는 환경변수값을 지정해서 사용한다.</p>\n</blockquote>\n<p>[your-theme-name]폴더 하위에 렌더링 형태를 결정할 layout 폴더와, 테마의 정적 리소스들이 들어갈 source 폴더를 만든다.</p>\n<h4 id=\"요약\"><a href=\"#요약\" class=\"headerlink\" title=\"요약\"></a>요약</h4><blockquote>\n<ol>\n<li>themes 폴더 &gt; [your-theme-name] 폴더 생성</li>\n<li>하위에 layout/source 폴더, _config.yml 만들기</li>\n</ol>\n</blockquote>\n<h2 id=\"layout-파일-만들기\"><a href=\"#layout-파일-만들기\" class=\"headerlink\" title=\"layout 파일 만들기\"></a>layout 파일 만들기</h2><p>폴더 구조를 잡았으면, [yout-theme-name]/layout 폴더 하위에 이제 페이지 골격을 이루는 파일을 만들어야 한다.<br>Hexo는 서버사이드 렌더링이나 클라이언트 사이드 렌더링을 할 때처럼 부분 렌더링을 지원한다.<br>이는 ejs나 pug 같은 뷰 엔진을 통해 이루어진다.</p>\n<p>특히 layout 파일은 테마의 전반적인 레이아웃을 결정한다.<br>메인 페이지, 블로그 페이지, 아카이브 페이지로 이동할 때, layout 파일 구조에 베이스를 잡고 하위에 페이지를 그린다.</p>\n<blockquote>\n<p>페이지별로 아예 다른 레이아웃을 적용하고 싶다면, 상위로 먼저 참조하는 layout을 이에 맞게 작성해야 한다.</p>\n</blockquote>\n<p>테마 폴더의 구조를 잡았으면 이제 렌더링할 뷰 엔진을 선택한다.<br>node.js를 하는 사람이라면 익숙한 뷰 엔진인 ejs 도 채택할 수 있다.<br>ejs를 사용한다면, 이에 맞는 layout 파일을 만든다.</p>\n<p><img src=\"/img/postimg/layout01.png\" alt=\"layout 파일 구조\"></p>\n<p>body 부분에 페이지가 이동될 때 페이지에 맞는 부분 레이아웃이 그려진다.</p>\n<h2 id=\"기본-페이지-추가하기\"><a href=\"#기본-페이지-추가하기\" class=\"headerlink\" title=\"기본 페이지 추가하기\"></a>기본 페이지 추가하기</h2><p>layout 파일을 작성했다면, 페이지의 레이아웃을 추가한다.</p>\n<h3 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h3><p>사이트에 진입했을 때, 가장 먼저 보여지는 페이지의 레이아웃은 index 페이지 레이아웃을 따른다.</p>\n<h3 id=\"archive\"><a href=\"#archive\" class=\"headerlink\" title=\"archive\"></a>archive</h3><p>아카이브 페이지는 주제별 카테고리 및 기간별 아카이브를 선택했을 때 그려지는 레이아웃이다.</p>\n<h2 id=\"부분-렌더링-페이지-쪼개기\"><a href=\"#부분-렌더링-페이지-쪼개기\" class=\"headerlink\" title=\"부분 렌더링(페이지 쪼개기)\"></a>부분 렌더링(페이지 쪼개기)</h2><p>Hexo는 앞서 말했듯이 뷰 엔진을 통한 부분 렌더링을 지원한다.<br>페이지 레이아웃에 통째로 작성해도 좋지만, 반복되는 구조 등이 있다면 partial 이라고 컴포넌트화 해서 위젯 붙이듯 붙여넣는 방법을 채택할 수도 있다.<br>이는 _partial 폴더 하위에 작성해서, partial 키워드로 렌더링 코드를 작성하면 된다.</p>\n<p><img src=\"/img/postimg/folder_structure.png\" alt=\"테마 폴더의 내부 구조\"></p>\n<p><img src=\"/img/postimg/layout01.png\" alt=\"작성한 partial 을 다음처럼 적용한다\"></p>\n<h2 id=\"정적-소스-불러오기\"><a href=\"#정적-소스-불러오기\" class=\"headerlink\" title=\"정적 소스 불러오기\"></a>정적 소스 불러오기</h2><p>source 폴더는 프로젝트의 루트에도 있고, 테마 내부에도 있다.</p>\n<p>테마 내부의 source 폴더는 블로그 포스팅에 사용되는 img 나 css, js 파일과 같은 정적 리소스를 두는 데에 사용한다.</p>\n<p><img src=\"/img/postimg/theme_source_folder.png\" alt=\"테마 내부의 source 폴더 안에는 정적 리소스가 들어간다\"></p>\n<h2 id=\"만든-테마-적용하기\"><a href=\"#만든-테마-적용하기\" class=\"headerlink\" title=\"만든 테마 적용하기\"></a>만든 테마 적용하기</h2><p>테마의 _config.yml이 아닌 프로젝트 루트 위치의 _config.yml에서 theme 명을<br>작성해 두었던 theme 명으로 변경한다.<br>변경사항을 저장하고 Hexo server를 가동하면 적용된 테마를 확인할 수 있다.</p>\n<h2 id=\"테마가-적용된-블로그-배포하기-github\"><a href=\"#테마가-적용된-블로그-배포하기-github\" class=\"headerlink\" title=\"테마가 적용된 블로그 배포하기(github)\"></a>테마가 적용된 블로그 배포하기(github)</h2><p>Hexo에는 배포 자동화 플러그인이 있다.<br>github에 배포하려면 hexo-deploy-git 플러그인을 사용하자.<br>프로젝트 루트의 _config.yml에서 deploy관련 설정을 작성해준다.<br><img src=\"/img/postimg/github_deploy_yml.png\" alt=\"깃허브 배포 yml 설정\"></p>\n<h2 id=\"테마-만들기-심화\"><a href=\"#테마-만들기-심화\" class=\"headerlink\" title=\"테마 만들기 심화\"></a>테마 만들기 심화</h2><h3 id=\"부가-페이지-만들기\"><a href=\"#부가-페이지-만들기\" class=\"headerlink\" title=\"부가 페이지 만들기\"></a>부가 페이지 만들기</h3><p>hexo new page [페이지명] 커맨드를 하면 프로젝트 루트의 source 폴더 내부에 [페이지명]으로 된 폴더가 생기는데, 페이지 주소를 받기 위해 index.md 가 내장되어 있다.</p>\n<p>프로파일처럼 아무 내용이 없더라도, 페이지는 만들어지며 .md 의 yml 부분에서 레이아웃을 설정해주지 않으면, 테마의 index.ejs의 레이아웃으로 적용된다.</p>\n<p>theme에서 부가적으로 만들 페이지의 레이아웃을 설정해준다.</p>\n<p>예시로 guest 나 prologue 등 부가적인 ejs를 생성한다.</p>\n<p>해당 테마는 guest나 prologue라는 이름의 레이아웃이 생기게 되며,<br>프로젝트 루트 폴더/source 내부의 페이지 이름으로 된 폴더 내부의 index.md의 layout 값을<br>해당 페이지의 layout 이름으로 지정해준다.</p>\n<p>서버를 가동하면 페이지에 레이아웃이 적용된 걸 확인할 수 있다.</p>\n<h3 id=\"댓글-위젯-달기-utterances\"><a href=\"#댓글-위젯-달기-utterances\" class=\"headerlink\" title=\"댓글 위젯 달기(utterances)\"></a>댓글 위젯 달기(utterances)</h3><p>포스트 페이지 아래에 utterances 플러그인을 삽입한다.</p>\n<p>git 이슈와 연동하는 권한을 utterances에게 부여해야 한다.</p>\n<p>Hexo 게시물의 퍼머링크와 해당 플러그인을 바인딩하면 각 포스트에 댓글을 달 때마다<br>포스트별로 이슈가 생성되고, 알람을 받아볼 수 있다.</p>\n<h3 id=\"손수-위젯-만들기\"><a href=\"#손수-위젯-만들기\" class=\"headerlink\" title=\"손수 위젯 만들기\"></a>손수 위젯 만들기</h3><p>partial 키워드가 부분 렌더링하는 걸 이용하여 위젯을 만들 수 있다.</p>\n<ul>\n<li>최근 포스트</li>\n<li>포스트의 내용 트래커</li>\n<li>카테고리 메뉴</li>\n<li>태그 클라우드 메뉴 등</li>\n</ul>\n<h3 id=\"커스텀-404-페이지-github\"><a href=\"#커스텀-404-페이지-github\" class=\"headerlink\" title=\"커스텀 404 페이지(github)\"></a>커스텀 404 페이지(github)</h3><p>배포를 깃허브에 하는 경우 source 폴더 바로 아래에 404.html 을 만들어 넣어두면<br>github에서 링크를 찾지 못할 때마다 404.html 로 리디렉션시킨다.</p>\n<p>잘 꾸며서 넣어두면 따로 라우팅을 설정할 필요가 없어 편리하다.</p>\n",
            "tags": [
                "hexo"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nb000mwc5o54vve0oa/",
            "url": "https://coding-coconut.com/post/cluwfj5nb000mwc5o54vve0oa/",
            "title": "SSH키로 로그인하는 법",
            "date_published": "2022-05-20T08:44:10.000Z",
            "content_html": "<h2 id=\"SSH키로-로그인하는-법\"><a href=\"#SSH키로-로그인하는-법\" class=\"headerlink\" title=\"SSH키로 로그인하는 법\"></a>SSH키로 로그인하는 법</h2><h3 id=\"SSH-키-생성하기\"><a href=\"#SSH-키-생성하기\" class=\"headerlink\" title=\"SSH 키 생성하기\"></a>SSH 키 생성하기</h3><p>깃허브나 벌쳐 인증서버/원격 데이터베이스에 접속할 때 키로그인을 필요로 하기도 한다.</p>\n<blockquote>\n<p>키 생성하기</p>\n</blockquote>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen</span><br></pre></td></tr></table></figure>\n<p>모든 설정 기본값으로 하면 내 컴퓨터/사용자 폴더/.ssh폴더(숨겨진 폴더)안에 다음처럼 rsa 키가 생성된다.</p>\n<ul>\n<li>id_rsa</li>\n<li>id_rsa.pub</li>\n</ul>\n<h3 id=\"키-파일-등록\"><a href=\"#키-파일-등록\" class=\"headerlink\" title=\"키 파일 등록\"></a>키 파일 등록</h3><p>ssh 를 이용해서 로그인하려면 이전 과정에서 생성된 두가지 키가 필요하다.</p>\n<ul>\n<li>id_rsa (클라이언트 피시가 가지고 있을 프라이빗 키. 이걸로 로그인함!)</li>\n<li>id_rsa.pub (호스트에 등록할 퍼블릭 키. 긁어서 호스트에 등록해야한다.)</li>\n</ul>\n<p>id_rsa는 다른 이름이거나 확장자가 <code>.ppk</code> 또는 <code>.pem</code>일 수 있다.</p>\n<blockquote>\n<p>.ssh 안에 프라이빗 키를 집어넣고, 퍼블릭 키는 파일을 열어 내부를 긁어서 호스트에 등록한다.</p>\n</blockquote>\n<h3 id=\"SSH-원격-접속-Config-파일-작성\"><a href=\"#SSH-원격-접속-Config-파일-작성\" class=\"headerlink\" title=\"SSH 원격 접속 Config 파일 작성\"></a>SSH 원격 접속 Config 파일 작성</h3><blockquote>\n<p>터미널 원격 ssh 접속 시 간편 커맨드를 위한 .ssh/config 파일을 설정한다.</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host [ConnectionName]</span><br><span class=\"line\">\tHostName [HostIP]</span><br><span class=\"line\">\tUser [HostLoginID]</span><br><span class=\"line\">\tIdentityFile ~/.ssh/[YOUR_PRIVATE_KEY_FILE]</span><br></pre></td></tr></table></figure>\n\n<p>위처럼 만들어 저장해 놓으면</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh [ConnectionName]</span><br></pre></td></tr></table></figure>\n<p>으로 간편하게 접속할 수 있다.</p>\n<p>키 파일 위치만 올바르다면 별도의 패스워드를 요구하진 않는다.</p>\n<h3 id=\"기타-파일변환\"><a href=\"#기타-파일변환\" class=\"headerlink\" title=\"기타 파일변환\"></a>기타 파일변환</h3><blockquote>\n<p>putty .ppk파일을 제네릭한 .pem으로 변환(윈도즈 putty가 있으면 ppk 그대로 사용해도됨)</p>\n</blockquote>\n<ul>\n<li>Mac 인 경우(선제 homebrew 설치 필요)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install putty </span><br><span class=\"line\">puttygen 원본.ppk -O private-openssh -o 내보낼.pem</span><br></pre></td></tr></table></figure></li>\n<li>Windows인 경우 putty-keygen exe를 이용한다.</li>\n</ul>\n",
            "tags": [
                "ssh",
                "terminal",
                "cmd",
                "bash"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nb000owc5oeom52klv/",
            "url": "https://coding-coconut.com/post/cluwfj5nb000owc5oeom52klv/",
            "title": "pm2와 클러스터화",
            "date_published": "2022-05-20T07:51:12.000Z",
            "content_html": "<h2 id=\"클러스터화-가동-설정-및-디버깅\"><a href=\"#클러스터화-가동-설정-및-디버깅\" class=\"headerlink\" title=\"클러스터화 가동 설정 및 디버깅\"></a>클러스터화 가동 설정 및 디버깅</h2><p>Node.js의 루트 바로 아래에 있는 인덱스 파일들은 package.json 설정 등을 통하면 멀티스레드로 실행할 수 있다.</p>\n<blockquote>\n<p>package.json 파일 설정과 pm2를 이용하여 별개의 프로그램을 클러스터화 가동한다.</p>\n</blockquote>\n<h3 id=\"1-pm2-npm-모듈-글로벌-옵션으로-깔기-클러스터-작동-확인을-위한-도구\"><a href=\"#1-pm2-npm-모듈-글로벌-옵션으로-깔기-클러스터-작동-확인을-위한-도구\" class=\"headerlink\" title=\"1. pm2 npm 모듈 글로벌 옵션으로 깔기(클러스터 작동 확인을 위한 도구)\"></a>1. pm2 npm 모듈 글로벌 옵션으로 깔기(클러스터 작동 확인을 위한 도구)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pm2 -g</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-클러스터화-파일-작성\"><a href=\"#2-클러스터화-파일-작성\" class=\"headerlink\" title=\"2. 클러스터화 파일 작성\"></a>2. 클러스터화 파일 작성</h3><p>  각 클러스터의 dev 실행 명령어 지정 및 클러스터화 시동 명령어 지정(package.json)</p>\n<blockquote>\n<p>package.json 작성 예제. daum/blog/post는 각기 실행할 별개의 index.ts파일이라고 보면 됨.</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;:&#123;</span><br><span class=\"line\">    &quot;start:cluster&quot;: &quot;pm2-runtime pm2.config.js&quot;,</span><br><span class=\"line\">    &quot;dev:post&quot;: &quot;nodemon --legacy-watch --watch ./ --exec &#x27;npx&#x27; ts-node -r tsconfig-paths/register ./src/post.ts&quot;,</span><br><span class=\"line\">    &quot;dev:blog&quot;: &quot;nodemon --legacy-watch --watch ./ --exec &#x27;npx&#x27; ts-node -r tsconfig-paths/register ./src/blog.ts&quot;,</span><br><span class=\"line\">    &quot;dev:daum&quot;: &quot;nodemon --legacy-watch --watch ./ --exec &#x27;npx&#x27; ts-node -r tsconfig-paths/register ./src/daum.ts&quot;,</span><br><span class=\"line\">    &quot;dev&quot;: &quot;npm run dev:blog &amp; npm run dev:daum &amp; npm run dev:post&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;tsc -p tsconfig.json &amp;&amp; tsc-alias&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>pm2.config.js 작성 예제. 클러스터화를 할 설정파일들을 지정한다. 인스턴스 갯수만큼 생성이 됨.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</span><br><span class=\"line\">    apps:[</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;post&quot;</span>, <span class=\"attr\">script</span>: <span class=\"string\">&quot;./dist/post.js&quot;</span>, <span class=\"attr\">instances</span>: <span class=\"number\">1</span>, <span class=\"attr\">exec_mode</span>: <span class=\"string\">&quot;cluster&quot;</span> &#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;blog&quot;</span>, <span class=\"attr\">script</span>: <span class=\"string\">&quot;./dist/blog.js&quot;</span>, <span class=\"attr\">instances</span>: <span class=\"number\">1</span>, <span class=\"attr\">exec_mode</span>: <span class=\"string\">&quot;cluster&quot;</span> &#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;daum&quot;</span>, <span class=\"attr\">script</span>: <span class=\"string\">&quot;./dist/daum.js&quot;</span>, <span class=\"attr\">instances</span>: <span class=\"number\">1</span>, <span class=\"attr\">exec_mode</span>: <span class=\"string\">&quot;cluster&quot;</span> &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-빌드하기\"><a href=\"#3-빌드하기\" class=\"headerlink\" title=\"3. 빌드하기\"></a>3. 빌드하기</h3><blockquote>\n<p>타입스크립트 파일들이 js로 빌드된다.</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-클러스터-가동\"><a href=\"#4-클러스터-가동\" class=\"headerlink\" title=\"4. 클러스터 가동\"></a>4. 클러스터 가동</h3><blockquote>\n<p>package.json에서 선제 명령어 설정을 해줘야 함</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start:cluster</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-이후-디버깅은-pm2-에서-할-수-있음\"><a href=\"#5-이후-디버깅은-pm2-에서-할-수-있음\" class=\"headerlink\" title=\"5. 이후 디버깅은 pm2 에서 할 수 있음\"></a>5. 이후 디버깅은 pm2 에서 할 수 있음</h3><blockquote>\n<p>가동되고 있는 클러스터 확인</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 list</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>클러스터 상세내역 확인(방향키로 조정)</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 monit</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>클러스터 가동 취소</p>\n</blockquote>\n<p>npm run start:cluster 명령어를 쳤던 커맨드창 ctrl+c </p>\n<p>이렇게 취소하면 pm2 list 했을 때 생성되었던 클러스터들이 사라진 것을 볼 수 있다.</p>\n",
            "tags": [
                "pm2"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nk0045wc5o1ld53db5/",
            "url": "https://coding-coconut.com/post/cluwfj5nk0045wc5o1ld53db5/",
            "title": "함수의 비동기화와 async 키워드",
            "date_published": "2022-01-27T00:56:15.000Z",
            "content_html": "<h1 id=\"함수의-비동기화\"><a href=\"#함수의-비동기화\" class=\"headerlink\" title=\"함수의 비동기화\"></a>함수의 비동기화</h1><p>기존 async await 를 단순히 비동기를 순차적으로 처리하는 데에만 이용하다가,<br>실무상 비동기로 함수를 처리해야 할 일이 생겼다.</p>\n<blockquote>\n<p>일반적인 자바스크립트 함수</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//그냥 함수</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자바스크립트 특성상 비동기 함수의 경우 일반 함수에서 호출 시 실행하라는 오더만 내리고 바로 다음 항목을 진행한다.</p>\n<blockquote>\n<p>비동기를 동기적으로 처리할 때, async await 의 사용법.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">somePromiseFunc</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//Promise 반환 함수인 somePromiseFunc.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//input do something..</span></span><br><span class=\"line\">         resolve(async_logic_result)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">         reject(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//async await 의 일반적인 사용.</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> somePromiseFunc() <span class=\"comment\">//비동기 함수의 응답을 받기 위해 await를 사용</span></span><br><span class=\"line\">    <span class=\"comment\">//do other func</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>async await 는 비동기 처리함수를 동기적으로 처리할 때 쓰이는 문법이다.<br>await는 async를 선언한 함수 내부에서만 쓸 수 있으며, Promise 를 반환하는 함수에 써서 result 변수에 resolve 내부에 들어가있는 결과값을 받을 수 있다.</p>\n<p>평소에 이렇게 비동기를 동기적으로 수행처리하는 과정만 생각하는게 주인데, 이번에는 업무상 응답속도를 줄이기 위해 의도적으로 함수를 비동기화해야하는 것이었다.</p>\n<blockquote>\n<p>실무에선 300줄 이상의 무거운 쿼리는 수행하라는 명령만 내리고, 문자열처럼 생성이 빠른 것들은 빨리 생성해서 바로 200 응답을 전송하길 원했다.</p>\n</blockquote>\n<p>이 방법을 찾는 과정에서 각 실행 방법의 응답속도를 비교했고, 더불어<br>async-await 키워드의 새로운 기능을 알게 되었다.</p>\n<br>\n\n<h1 id=\"속도-비교\"><a href=\"#속도-비교\" class=\"headerlink\" title=\"속도 비교\"></a>속도 비교</h1><h2 id=\"1-일반-실행\"><a href=\"#1-일반-실행\" class=\"headerlink\" title=\"1. 일반 실행\"></a>1. 일반 실행</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someHeavyFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//무거운 쿼리 로직. query를 때릴 때 사용하는 모듈 자체는 비동기식으로 작동한다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callAsyncFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_key = otherModule.keyMaker(someInput); <span class=\"comment\">//빠른 실행이 가능한 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    someHeavyFunc()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_answer=&#123;</span><br><span class=\"line\">        key:fast_key</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fast_answer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>javascript는 기본적으로 비동기로 작동한다고 하지 않았었나..? 하지만 Postman과 console.log로 각 함수 실행과정과 응답속도를 테스트한 결과, 200 응답 뒤에 무거운 함수가 실행되는 경우는 없었다.</p>\n<p><img src=\"/img/postimg/default_do.png\" alt=\"default_do\"><br>거진.. 요청당 약 1초가 걸린다. 어마무시하다.</p>\n<h2 id=\"2-setTimeout-함수\"><a href=\"#2-setTimeout-함수\" class=\"headerlink\" title=\"2. setTimeout 함수\"></a>2. setTimeout 함수</h2><p>두 번째로는 비동기 함수의 개념을 배울 때 주로 사용하는 setTimeout으로 테스트하였다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someHeavyFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//무거운 쿼리 로직..</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callAsyncFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_key = otherModule.keyMaker(someInput); <span class=\"comment\">//빠른 실행이 가능한 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        someHeavyFunc()</span><br><span class=\"line\">    &#125;,<span class=\"number\">50</span>) <span class=\"comment\">//비동기 처리를 위해서는 어쩔 수 없나...? 근데 진짜 이렇게?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_answer=&#123;</span><br><span class=\"line\">        key:fast_key</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fast_answer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>async 키워드를 함수 앞에 붙인다는 게 무슨 뜻인지 제대로 알지 못해서 생긴 폐해다(…)</p>\n<p><img src=\"/img/postimg/settimeout_do.png\" alt=\"settimeout_do\"><br>응답속도가 많이 줄었다. setTimeOut 함수가 비동기 함수인 걸 알고 return을 먼저 보내고 무거운 함수를 실행한 것이다. 속도 개선은 되었지만, 당연스럽게도 setTimeOut함수를 사용하면 초반지연이 발생한다.</p>\n<p>앞서 실험했던 일반 실행과 비교해봤을 때, 이는 js가 봤을 때 함수가 비동기임을 몰라서 생기는 상황인 것 같았다.</p>\n<ul>\n<li>그러면 어떻게 비동기 함수인걸 알려줘야할까?</li>\n</ul>\n<p>답은 async-await 페어 중 async에 있었다.</p>\n<h2 id=\"3-async-키워드\"><a href=\"#3-async-키워드\" class=\"headerlink\" title=\"3. async 키워드\"></a>3. async 키워드</h2><blockquote>\n<p>async 키워드는 함수를 비동기 취급한다.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someHeavyFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//무거운 쿼리 로직..</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callAsyncFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_key = otherModule.keyMaker(someInput); <span class=\"comment\">//빠른 실행이 가능한 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    someHeavyFunc()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_answer=&#123;</span><br><span class=\"line\">        key:fast_key</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fast_answer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>무거운 함수 앞에 async를 붙이고, 무거운 함수를 호출하는 함수는 async 키워드를 붙이지 않는다.<br>async 키워드를 붙이지 않았으니, await도 쓸 수 없다.<br>결과는 어떨까?</p>\n<p><img src=\"/img/postimg/async_do.png\" alt=\"async_do\"></p>\n<p>성공이다! 원하는 응답도 제대로 가져온다.</p>\n<h1 id=\"응용\"><a href=\"#응용\" class=\"headerlink\" title=\"응용\"></a>응용</h1><p>… 그러면 특정 부분은 비동기로 수행하고 비동기 함수끼리는 동기적으로 처리하고 싶을 때, 이렇게 하면 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">caller</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//caller는 일반 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> faster = doMakeFaster() <span class=\"comment\">//일반 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAsync</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//비동기로 묶어서 처리할 랩퍼를 선언</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> result1= <span class=\"keyword\">await</span> someAsyncFunc() <span class=\"comment\">//비동기 함수를 순차적으로 시행</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> someAsyncFunc2(result1) <span class=\"comment\">//비동기 함수를 순차적으로 시행</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    doAsync() <span class=\"comment\">//비동기로 시행</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> faster;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>faster 먼저 변수에 결과값이 담기고, doAsync()는 명령만 내린 뒤 바로 return 값을 반환한다. 이후 doAsync() 함수 수행 명령을 내린 시점에서 someAsyncFunc()와 someAsyncFunc2가 순차적으로 실행된다.</p>\n<p>비동기 처리를 동기적으로 수행하기 위해 여태껏 await에만 초점을 맞추고 있었는데, 이번엔 await를 사용하지 않고 async만 사용해 보았다.<br>async-await는 기본적으로 페어지만, 함수를 비동기로 실행할 때도 있는 법이다.<br>두 키워드를 좀더 제대로 알게 된 것 같아 기쁘다. 유익한 경험이었다.</p>\n",
            "tags": [
                "비동기",
                "asyncawait",
                "postman",
                "속도 개선"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nk0043wc5odnbu4aln/",
            "url": "https://coding-coconut.com/post/cluwfj5nk0043wc5odnbu4aln/",
            "title": "블로그 새단장",
            "date_published": "2022-01-21T07:40:37.000Z",
            "content_html": "<p>기존 블로그 레이아웃과 테마를 새로 리뉴얼했다!<br>깔끔해서 마음에 든다.</p>\n<p>이번에 새 테마를 만들면서, 기존 Hexo 공식 문서를 많이 파악해 보는 시간을 가졌다.<br>조만간 레이아웃 만들기도 정리해서 포스팅할 예정.</p>\n",
            "tags": [
                "잡담"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nk0041wc5o7w0r2aim/",
            "url": "https://coding-coconut.com/post/cluwfj5nk0041wc5o7w0r2aim/",
            "title": "링크 스크랩 및 참고자료",
            "date_published": "2021-09-17T00:30:08.000Z",
            "content_html": "<h3 id=\"리눅스-명령어들\"><a href=\"#리눅스-명령어들\" class=\"headerlink\" title=\"리눅스 명령어들\"></a>리눅스 명령어들</h3><p><code>sudo grep -ir &#39;bind-address&#39; /etc/mysql/</code><br>해당 위치에 원하는 텍스트가 있는 파일을 찾는 명령어</p>\n<p><code>iptables -I INPUT -s 1.1.1.1 -j DROP</code><br>특정 IP막기</p>\n<blockquote>\n<p><a href=\"https://thisblogbusy.tistory.com/entry/iptables-%ED%8A%B9%EC%A0%95-IP-%EB%A7%89%EA%B8%B0?category=692140\">https://thisblogbusy.tistory.com/entry/iptables-특정-IP-막기?category=692140</a> </p>\n</blockquote>\n<p><code>cat /var/log/apache2/access.log</code></p>\n<p><code>tail access.log</code><br>접속 기록 확인</p>\n<p><code>nohup npm start &amp;</code><br>노헙으로 종료가되어도 계속 실행되도록 백그라운드로 npm start실행.</p>\n<h3 id=\"https-인증\"><a href=\"#https-인증\" class=\"headerlink\" title=\"https 인증\"></a>https 인증</h3><p>호스트 서버컴퓨터에 snap 깔고 certbot 깔고</p>\n<p><code>certbot --apache</code></p>\n<p>리버스프록시로 아파치를 설정해뒀다면 아파치 사양으로 certbot이 자동으로 인증서를 설정해줌.</p>\n<h3 id=\"ip-접속기록-확인-아파치-이용\"><a href=\"#ip-접속기록-확인-아파치-이용\" class=\"headerlink\" title=\"ip 접속기록 확인 (아파치 이용)\"></a>ip 접속기록 확인 (아파치 이용)</h3><p><code>sudo awk &#39;&#123; print $1&#125;&#39; /var/log/apache2/access.log | sort | uniq -c | sort -nr | head -n 10</code><br>접속기록 빈도 10위까지 출력</p>\n<h3 id=\"ssh-키페어-등록하기\"><a href=\"#ssh-키페어-등록하기\" class=\"headerlink\" title=\"ssh 키페어 등록하기\"></a>ssh 키페어 등록하기</h3><blockquote>\n<p><a href=\"https://extrememanual.net/26803\">https://extrememanual.net/26803</a></p>\n</blockquote>\n<ol>\n<li><p>puttygen 이용, rsa 키페어 생성</p>\n</li>\n<li><p>퍼블릭키와 프라이빗키 저장</p>\n</li>\n<li><p>호스트 서버 들어가서 유저계정 고유 폴더에 .ssh 폴더 만들기</p>\n</li>\n</ol>\n<p><code>mkdir .ssh</code></p>\n<p><code>vi .ssh/authorized_keys</code></p>\n<ol start=\"4\">\n<li>해당 편집기에 public key 부분을 텍스트 붙여넣기 후 저장</li>\n</ol>\n<h3 id=\"드래그앤드롭-라이브러리\"><a href=\"#드래그앤드롭-라이브러리\" class=\"headerlink\" title=\"드래그앤드롭 라이브러리\"></a>드래그앤드롭 라이브러리</h3><blockquote>\n<p><a href=\"https://interactjs.io/\">https://interactjs.io/</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://web.dev/drag-and-drop/\">https://web.dev/drag-and-drop/</a></p>\n</blockquote>\n<p>드래그앤드롭 파일 업로드 및 설명 튜토리얼.</p>\n<h3 id=\"Electron-시작하기\"><a href=\"#Electron-시작하기\" class=\"headerlink\" title=\"Electron 시작하기\"></a>Electron 시작하기</h3><blockquote>\n<p><a href=\"https://musma.github.io/2019/07/17/electron-getting-started.html\">https://musma.github.io/2019/07/17/electron-getting-started.html</a></p>\n</blockquote>\n<p>Electron을 이용해서 node.js 와 js로 데스크톱 어플리케이션을 만들 수 있다.</p>\n",
            "tags": [
                "스크랩"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5n30003wc5ob3i61w6s/",
            "url": "https://coding-coconut.com/post/cluwfj5n30003wc5ob3i61w6s/",
            "title": "Certbot으로 https 서브도메인 등록하기",
            "date_published": "2021-08-12T23:55:12.000Z",
            "content_html": "<p>시행착오가 좀 많았다.</p>\n<p>회사서 홈페이지를 새로 구축했다. 구축하는 김에 구식이었던 정적 호스팅을 버리고.. 서버도 올릴 수 있도록 요즘 클라우드 호스팅으로 갈아탔다!</p>\n<p>AWS EC2처럼 가상컴퓨터지만.. 클라우드라서 훨씬 가격이 저렴하다.  (사실 써본 입장으로써 AWS는 좀 깡패라는 생각이 든다 가격 측정상…ㅡ,.ㅡ)</p>\n<p>클라우드 중 가장 싸다는 Vultr호스팅을 이용하고 싶었으나.. 회원가입할때 1인 1계정 원칙이 있는데, 하필이면 잘 모르는 초짜 고고넛이 회원가입할 때 실수를 해서 락이 걸렸다. </p>\n<p>문의 처리는 빨랐지만  Vultr가 해외 호스팅 서버라 처리하는게 좀 번거로워서..  고심한 끝에,</p>\n<p>cafe24의 클라우드 호스팅 서비스를 이용하기로 결정했다.</p>\n<p>가격도 Vultr 랑 비교해서 둘이 비슷하다! 성능은 cafe24 클라우드 호스팅 쪽이 램을 더 잘 지원하고.. 용량이 쪼끔 더 작다.(벌쳐는 램이 작고 용량이 큰 편) 그리고.. 벌쳐는 클라우드 서버를 사면 공인 IP도 같이 주는데 cafe24쪽은 공인 IP를 따로 사야한다.</p>\n<p>사내 홈피처럼 공적인 부분은 공인 IP가 꼭 필요하므로~ 공인 IP도 클라우드 서버와 같이 구매했다.</p>\n<p>개인 블로그 구축을 경험삼아 Ubuntu 18 바이오닉 서버에 Node.js Express서버를 배포하려고 했다.</p>\n<p>cafe24클라우드의 특성상 보안을 위해 SSH키를 사용해야만 접속할 수 있고,</p>\n<p>SSH 키는 cafe24클라우드가 서버 살 때 키까지 만들어준다.</p>\n<p>SSH 키로 접속할때 고고낫은 Putty를 이용했으므로, 키를 읽어서 변환해주는 puttygen이 필요했다.</p>\n<p>홈피서 pem 키를 받고 puttygen에서 불러오기를 하면 exe프로그램이 putty전용으로 key를 변환해준다.</p>\n<p>save Private Key를 하면 ppk로 내려지는데,</p>\n<p>Putty &gt; Connection &gt; SSH &gt; Auth 에서 맨 밑 항목을 보면 Private key file for authentication 하고 ppk키를 등록하는 부분이 있다.</p>\n<p>푸티에도 등록해주고, 파일질라에도 상단의 사이트 관리자 항목을 보면 키를 등록해주는 부분이 있다.</p>\n<blockquote>\n<p>❕  Putty 와 Filezila 연결을 위한 방화벽 설정은 cafe24 클라우드 웹콘솔 화면에서 사람이 정말~ 설정하기 쉽도록 되어 있다. ufw 치고.. 막 콘솔 창 안 들여다봐도 된다 ㅎㅎ</p>\n</blockquote>\n<p>여튼 key를 이용해서 putty로 ssh접속하면, 지정된 계정 이름으로 접속하게 되어있는데, 이 계정한텐 root권한이 없어서 명령수행 할 때 일시적으로 제약을 해제해줘야 했다.</p>\n<p><code>sudo -i</code></p>\n<p>파일질라로 배포할 파일 업로드하는 과정은 생략한다. Express(Node)는 일종의 SSR서버이므로~ 직접 접근하게 하면 좀 위험하고 정적 서버인 apache를 통해 프록시하면 좋을 것 같아서 apache2도 깔았다. 프록시설정하는 과정도 생략한다!</p>\n<p>인터넷 상으로 접속 확인하고 ip도메인 연결하고 도메인 주소를 치면 사이트가 다 뜨는 것까지 확인했다.(다만 http일 뿐이지..)</p>\n<h3 id=\"본론\"><a href=\"#본론\" class=\"headerlink\" title=\"본론!\"></a>본론!</h3><p>서론이 쫌 길었다.. 클라우드 얘기만 대판 ..ㅡ.ㅡ) 이제 https를 등록할 차례인데,</p>\n<p>Certbot이 너무 친절한게.. 공식 사이트 가서 서버 종류랑 컴퓨터 운영체제를 입력하면 어떻게 깔아야 하는지 튜토리얼이 너무 잘 되어있다…ㅠ.ㅠ</p>\n<p><a href=\"https://certbot.eff.org/lets-encrypt/ubuntubionic-apache\">https://certbot.eff.org/lets-encrypt/ubuntubionic-apache</a></p>\n<p>아파치 사양으로 하라는 대로 했다. 여기까진 아무 문제 없었다. 근데 왠걸.. 선택지가 두개 뜨는데, 한 도메인은 www를 포함하고, 다른 한 도메인은 www를 포함하지 않는 도메인을 보여주면서 둘 중 인증서 발급 받을 주소를 하나 택하라고 한다</p>\n<p>둘다 발급받을건데.? 하고 서트봇 인증서 발급 명령을 두번 실행하면</p>\n<p>인증서는 두개인데.. 사이트 들어가서 확인해봤더니만,</p>\n<p>정작 적용은 맨 마지막에 발급받은 인증서 하나만 되는 것 같았다.</p>\n<p>여기서 좀 많이 해멨는데, 방법은.. 인증서를 하나만 발급받고 (www든 www가 아니든)</p>\n<p>아래처럼 서브도메인으로 인증서를 확장하는 명령을 내리는 것이었다.</p>\n<p><code>certbot --expand -d existing.com,example.com,newdomain.com</code></p>\n<p>이렇게 하면 하나의 인증서 아래에 여러 서브도메인이 붙는다.</p>\n<p>여튼 이걸로 도메인 여러개 발급받는 것 해결했음…</p>\n",
            "tags": [
                "certbot"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5na000hwc5o479f2xmx/",
            "url": "https://coding-coconut.com/post/cluwfj5na000hwc5o479f2xmx/",
            "title": "Hexo와 API 서버 간의 통신",
            "date_published": "2021-03-08T07:46:45.000Z",
            "content_html": "<p>Hexo 블로그에 서버 API를 이용하는 덧글 위젯을 직접 만들고 싶다면 참조할 수 있는 포스팅이다.<br>Hexo는 정적 웹 블로그를 빠르게 작성할 수 있도록 하는 데에 주요 목적이 있기 때문에, 쿼리를 통해 데이터를 가져오고 서버통신을 통해 html dom을 렌더링하는 로직에 대한 지원은 그다지 좋지 않다.<br> Hexo 공식 사이트에서 지원하는 플러그인, 또는 Disqus나 Utterances 와 같은 덧글 위젯이 있지만.. 이런 위젯은 커스터마이징이나 데이터 저장 방식이 유연하지 못하다는 게 사실이다.</p>\n<p>요약해서 말하자면, 결국 개발자들의 입맞에 맞지 않기 때문에 커스텀 위젯을 만들고자 하는 것이다 ^^;;</p>\n<blockquote>\n<p>뭘 만들 것인가?</p>\n</blockquote>\n<p>Hexo처럼 정적 프레임워크와 같이 사용할 수 있는, 덧글 위젯을 만들려고 한다.</p>\n<blockquote>\n<p>어떻게 만들 것인가?</p>\n</blockquote>\n<p>Hexo와 호환되려면 어떻게 해야 할까?<br>Hexo는 정적 블로그형 웹페이지 제작에 최적화된 별도의 서버를 가지고 있다. 이 서버는 Hexo를 가동시킬 때 .md(마크다운) 파일을 html로 내려준다.</p>\n<p>*문제점 : Hexo와 위젯 API서버가 다르기 때문에 크로스오리진 이슈가 발생한다.</p>\n<p>:할 수 있는 방법</p>\n<blockquote>\n<p>위젯 따로 구동되는 방식을 이용해야 한다. 다른 웹페이지를 볼 수 있는 iframe 태그를 이용할수도 있고, 데이터만 전송받아 Hexo 상에서 DOM을 따로 그릴 수도 있다. 데이터 교환 방식은 ajax 또는 axios를 이용할 것이다.</p>\n</blockquote>\n<p>흐름 구상은 다음과 같다.</p>\n<ol>\n<li>Hexo에서 ajax 혹은 axios를 이용하여 데이터를 요청한다.</li>\n<li>api를 통해 댓글 데이터를 전송한다.</li>\n<li>전송된 데이터를 받아서 Hexo상에서 HTML DOM을 직접 그린다.</li>\n</ol>\n<p>..해서 다음과 같은 과정이 될 것이다.</p>\n<ul>\n<li>Hexo ajax 요청 =&gt; 위젯 API의 수신 및 응답 =&gt; Hexo ajax 응답 완료 =&gt; Hexo의 js로 DOM 렌더링</li>\n</ul>\n<blockquote>\n<p>그렇다면 이제 뭘 이용해서 구현할까?</p>\n</blockquote>\n<p>페이지를 렌더링해서 iframe하는 방식도 해봤고 데이터만 받아와서 hexo상에서 렌더링하는 방식도 해봤는데<br>iframe은 크로스오리진 이슈 때문에 iframe 내부의 DOM을 조작하기가 까다로워서 ajax 요청을 통해 api 서버로부터 데이터를 받아와서<br>Hexo 측에서 댓글 위젯을 그리는 편을 택했다.</p>\n<h3 id=\"1-Node-js-Express-프레임워크로-위젯이-가동될-서버-만들기\"><a href=\"#1-Node-js-Express-프레임워크로-위젯이-가동될-서버-만들기\" class=\"headerlink\" title=\"1. Node.js Express 프레임워크로 위젯이 가동될 서버 만들기\"></a>1. Node.js Express 프레임워크로 위젯이 가동될 서버 만들기</h3><!-- 이미지 -->\n<p>express를 사용하여 api 서버의 틀을 잡는다.</p>\n<!-- 이미지 -->\n<p>댓글이 저장될 데이터베이스 또한 작성해야 한다.</p>\n<h3 id=\"2-위젯-서버의-API-로직-작성하기\"><a href=\"#2-위젯-서버의-API-로직-작성하기\" class=\"headerlink\" title=\"2. 위젯 서버의 API 로직 작성하기\"></a>2. 위젯 서버의 API 로직 작성하기</h3><!-- 이미지 -->\n<p>Node Express 서버에 기본 CRUD를 할 수 있도록 기능을 만든다.</p>\n<h3 id=\"3-Hexo-ajax-요청-로직-작성\"><a href=\"#3-Hexo-ajax-요청-로직-작성\" class=\"headerlink\" title=\"3. Hexo ajax 요청 로직 작성\"></a>3. Hexo ajax 요청 로직 작성</h3><!-- 이미지 -->\n<p>Hexo 댓글 위젯의 버튼을 누르면 ajax 또는 axios 를 통해 위에서 작성한 api에 데이터를 요청할 수 있도록 한다.</p>\n<h3 id=\"4-댓글-DOM-렌더링-로직-작성\"><a href=\"#4-댓글-DOM-렌더링-로직-작성\" class=\"headerlink\" title=\"4. 댓글 DOM 렌더링 로직 작성\"></a>4. 댓글 DOM 렌더링 로직 작성</h3><!-- 이미지 -->\n<p>데이터 전송이 끝나면 추가되는 댓글 또는 삭제되는 댓글을 렌더링할 수 있도록 html DOM 렌더러를 작성한다.</p>\n<h3 id=\"5-댓글이-갱신되는것을-확인\"><a href=\"#5-댓글이-갱신되는것을-확인\" class=\"headerlink\" title=\"5. 댓글이 갱신되는것을 확인\"></a>5. 댓글이 갱신되는것을 확인</h3><!-- 이미지 -->\n<p>댓글이 잘 작성된 것을 확인할 수 있었다.<br>지금은 익명 댓글이지만, 로그인 위젯을 만들어 놓으면 api 서버로부터 세션검증을 통해 유저검증을 하는 것도 가능할 것 같다.</p>\n",
            "tags": [
                "hexo"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5na000jwc5o3jlndz0q/",
            "url": "https://coding-coconut.com/post/cluwfj5na000jwc5o3jlndz0q/",
            "title": "Hexo 테마 블로그 적용기",
            "date_published": "2021-02-09T03:19:02.000Z",
            "content_html": "<p>블로그의 첫 게시물은 도커가 장식했지만, 그래도 명색이 헥소로 기껏 만든 블로그인데 적용기를 써보자~<br>다른 블로그를 봐도 헥소 테마 레이아웃을 만드는 방법은 잘 나와있지 않아서, 이왕 하는 김에 테마 만드는 법도 같이 기술하련다.<br>헥소 프레임워크를 좀 만져봤는데, 작동원리는 쪼끔 알겠고 헥소 기반 테마 만드는법을 모르는 사람에게 추천한다. 헥소 공식 사이트에도 만드는 방법이 어렴풋하게나마 나와있으니 참조해도 좋다(그리 자세히 나와있진 않지만..)</p>\n<h3 id=\"1-레이아웃-폴더-만들기\"><a href=\"#1-레이아웃-폴더-만들기\" class=\"headerlink\" title=\"1. 레이아웃 폴더 만들기\"></a>1. 레이아웃 폴더 만들기</h3><p>우선… 블로그 폴더 구조는 다음과 같다.</p>\n<p><img src=\"/img/postimg/blog_structure.png\" alt=\"blog_structure\"></p>\n<p>먼저  프로젝트 루트 폴더에 themes 폴더를 만들고, 내부에 자기가 만들 테마의 이름을 짓자.<br>이 안에 블로그 틀이 들어갈 📁layout 폴더와 img/js/font처럼 정적 소스들이 들어갈 📁source 폴더를 만든다.<br>블로그 테마에 적용시킬 변수들을 모아 관리하는 <code>_config.yml</code>파일도 만든다.</p>\n<h3 id=\"3-렌더링할-템플릿-엔진-선택\"><a href=\"#3-렌더링할-템플릿-엔진-선택\" class=\"headerlink\" title=\"3. 렌더링할 템플릿 엔진 선택\"></a>3. 렌더링할 템플릿 엔진 선택</h3><p>필자는 Express를 사용해와서.. 상대적으로 익숙한 ejs로 작성할 것이다.<br>블로그의 전체 레이아웃을 담당하는 <code>layout.ejs</code> 파일을 📁layout 폴더 안에 만들어준다.<br>이 <code>layout.ejs</code> 파일이 블로그의 뼈대 역할을 해줄 것이다.</p>\n<h3 id=\"4-부분-렌더링-파츠별로-작성\"><a href=\"#4-부분-렌더링-파츠별로-작성\" class=\"headerlink\" title=\"4. 부분 렌더링 파츠별로 작성\"></a>4. 부분 렌더링 파츠별로 작성</h3><p>📁layout 폴더 안에 각 부분별 파츠가 들어갈📁_partial 폴더를 만들어주고, <code>layout.ejs</code> 파일을 한번 보자.</p>\n<h3 id=\"5-레이아웃-변수를-담당할-config-yml-파일-작성\"><a href=\"#5-레이아웃-변수를-담당할-config-yml-파일-작성\" class=\"headerlink\" title=\"5. 레이아웃 변수를 담당할 _config.yml 파일 작성\"></a>5. 레이아웃 변수를 담당할 _config.yml 파일 작성</h3><p>ejs 문법 속에 동적으로 들어갈 변수들을 yml 로 작성한다.</p>\n<h3 id=\"6-부가적인-것\"><a href=\"#6-부가적인-것\" class=\"headerlink\" title=\"6. 부가적인 것\"></a>6. 부가적인 것</h3><blockquote>\n<p>서버 통신이 필요한 무언가를 만들고 싶다.. 가령 댓글이라거나..</p>\n</blockquote>\n<p>Hexo가 직접 댓글서비스를 지원하진 않지만, 관련 플러그인을 지원한다.<br>댓글을 붙이고 싶다면, 상세한 커스터마이징 없이 <a href=\"https://utteranc.es/\">Utterances</a>나 <a href=\"https://help.disqus.com/en/\">Disqus</a>처럼 댓글 위젯을 서비스받는 방법도 있다. Hexo 에서 직접 추천하는 방법이며, 공식 메뉴얼도 있다!</p>\n<p>직접 만들고 싶다면, 아쉽게도 Hexo는 정적 서비스를 중점적으로 빠르게 작성하기 위한 프레임워크이기 때문에, 서버통신이 필요한 무언가를 작성할 때 그렇게 용이하지는 않다. 이렇게 되면.. 정적 소스 폴더 안의 js로 직접 서버 API로 ajax를 날리는 방법을 택해야💦..</p>\n<p>이럴 바에야 차라리 서버사이드 렌더링(SSR) 방식으로 만드는 게 더 낫지 않은가 고민해보길 바란다. </p>\n<p>그래도 Hexo 블로그에 서버 API를 이용하는 덧글 위젯을 직접 만들고 싶다면… <a href=\"#\">[링크]:Hexo 와 API 서버 간의 통신</a></p>\n<blockquote>\n<p>iframe 으로 위젯 만들기?</p>\n</blockquote>\n<p>iframe 내부에 들어갈 위젯이 고정 높이폭과 너비를 가진다면 가능하다!<br>혹은 position: absolute; 로 동동 떠 있으면 iframe으로 위젯을 만들어도 좋다.</p>\n",
            "tags": [
                "hexo"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5n70009wc5o89ms4a09/",
            "url": "https://coding-coconut.com/post/cluwfj5n70009wc5o89ms4a09/",
            "title": "Docker 명령어 정리",
            "date_published": "2021-02-05T00:00:04.000Z",
            "content_html": "<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Docker_%28container_engine%29_logo.svg/1200px-Docker_%28container_engine%29_logo.svg.png\" alt=\"titleimg\"></p>\n<p>도커를 한번 써 보니 생각보다 서버를 운영하는 데 편리하고 컨테이너 단위 관리가 용이해서, 이를 잊어버리는 일이 없도록 실행부터 가동 중지까지, 방법을 정리하려고 한다.</p>\n<h3 id=\"1-서버-이미지-만들기\"><a href=\"#1-서버-이미지-만들기\" class=\"headerlink\" title=\"1. 서버 이미지 만들기\"></a>1. 서버 이미지 만들기</h3><p>서버 구축 후, 프로젝트 폴더를 Shift + 우클릭하여 cmd(명령 프롬프트 창) 실행</p>\n<p>Docker Desktop 이 설치되어있고, 가동시켜서 현재 서비스가 돌아가고 있다는 전제 하에 아래의 명령어를 입력</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t [생성할 이미지명] .</span><br></pre></td></tr></table></figure>\n\n<p>생성할 이미지명 예시 : ex) MyContainer</p>\n<p>온점까지 제대로 입력해야한다.<br>해당 명령어를 실행하면, 도커가 프로젝트의 Dockerfile 이 제대로 작성되었다는 가정하에 Dockerfile 내부의 명령어를 실행시켜 컨테이너를 구축한다. 실행 예시는 다음 링크를 참조 <a href=\"https://hexo.io\">[링크]:도커파일 작성하기(Node.js Express)</a></p>\n<h3 id=\"2-이미지-실행하기\"><a href=\"#2-이미지-실행하기\" class=\"headerlink\" title=\"2. 이미지 실행하기\"></a>2. 이미지 실행하기</h3><p>이미지를 빌드해서 생성했으면, 이제 컨테이너화하여 서버를 운영할 수 있다.</p>\n<blockquote>\n<ol>\n<li>Docker Desktop 가동</li>\n<li>좌측의 Images 에 지정했던 이미지명 찾기</li>\n<li>RUN 을 통해 가동 (세부설정은 Optional Settings를 통해 설정할 수 있다. 컨테이너명과 Port 등을 지정할 수 있다.)</li>\n<li>성공적으로 가동하면 왼측 Containers/Apps 의 컨테이너 목록란에 초록색 컨테이너 박스로 표기된다.</li>\n</ol>\n</blockquote>\n<p>+) 만약 Dockerfile 등의 결함이 있거나 하면 shell 실행이 중지되는데,<br><img src=\"/img/postimg/container_disable.png\" alt=\"containericon\"><br>요로코롬 컨테이너 아이콘이 회색으로 표기된다.<br>클릭을 통해 해당 로그란을 확인할 수 있다.<br>이 경우에는 파일 빌드 자체에 오류가 있는 경우이므로 이미지를 재빌드해야만 한다.</p>\n<h3 id=\"3-컨테이너-실행-확인\"><a href=\"#3-컨테이너-실행-확인\" class=\"headerlink\" title=\"3. 컨테이너 실행 확인\"></a>3. 컨테이너 실행 확인</h3><p>도커 위에서 돌아가고 있는 이미지 컨테이너를 확인해 보자.<br><img src=\"/img/postimg/container_correct.png\" alt=\"containericon\"><br>정상적으로 돌아가고 있다면 컨테이너 박스가 녹색으로 표기된다.<br>필자는 웹서버이므로 웹 연결을 통해 컨테이너가 해당 로컬 포트를 통해 돌아가고 있는 것을 확인하였다.<br>이미지 가동 시 포트를 따로 뚫어 뒀다면 포트포워딩을 통해 포팅하고있는 컴퓨터의 외부 접속도 가능하다.</p>\n<h3 id=\"4-컨테이너-중지\"><a href=\"#4-컨테이너-중지\" class=\"headerlink\" title=\"4. 컨테이너 중지\"></a>4. 컨테이너 중지</h3><p><img src=\"/img/postimg/active_server_delete.png\" alt=\"containericon\"></p>\n<blockquote>\n<p>위 그림처럼 Docker Desktop의 Container/Apps 목록에서 컨테이너를 Delete 한다.</p>\n</blockquote>\n<p>서버에 대한 이미지는 기존에 작성해 놓았기 때문에 컨테이너를 삭제해도 무방하다!<br>재가동시킬 땐 이미지를 다시 가동시키면 되니깐..</p>\n<h3 id=\"5-그-외-명령어들\"><a href=\"#5-그-외-명령어들\" class=\"headerlink\" title=\"5. 그 외 명령어들\"></a>5. 그 외 명령어들</h3><blockquote>\n<p>파일 접근하기 </p>\n</blockquote>\n<p>+) 서버가 돌아갈때 로그 등을 생성하도록 해두었다면, 현재 돌아가고 있는 컨테이너의 내부 파일에 접근하는 것도 가능하다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker cp [컨테이너명]:[접근할 파일 경로] [저장할 경로명]</span><br></pre></td></tr></table></figure>\n\n<p>컨테이너명 예시 : ex) MyConatiner<br>접근할 파일 경로 예시 : ex)/root/etc/logs<br>파일을 저장할 경로명 예시: ex) C:\\Users\\Desktop\\Server_Container_Logs</p>\n<p>위 커맨드를 실행하면 서버 내부의 로그파일을 빼낼 수 있다!</p>\n<blockquote>\n<p>컨테이너 내부 시간대 맞추기</p>\n</blockquote>\n<p>+) 이미지 가동 시 옵셔널 세팅에 포함되지 않은 기능이다.. ㅡ.ㅡ 왜 이렇게 해놓았을까..?<br> 다소 곤란한 감이 있지만 이 경우도 명령어로 제어가 가능하다.<br> 컨테이너 가동 시에 시간대를 국제시간대로 맞춰주면 된다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --name [컨테이너명] -p [로컬로 접근할 포트명]:[컨테이너 내부로 뜷어놓을 포트명]</span><br><span class=\"line\">-e TZ&#x3D;Asia&#x2F;Seoul [이미지명]</span><br></pre></td></tr></table></figure>\n\n<p> 이런 식으로 가동하면 -e 커맨드를 통해 이미지 컨테이너의 시간대가 서울로 설정되어 가동된다.</p>\n",
            "tags": [
                "docker",
                "hexo"
            ]
        }
    ]
}
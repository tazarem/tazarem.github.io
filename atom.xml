<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://coding-coconut.com</id>
    <title>Coding Coconut</title>
    <link href="https://coding-coconut.com" />
    <updated>2022-08-24T09:14:09.000Z</updated>
    <category term="certbot" />
    <category term="docker" />
    <category term="hexo" />
    <category term="dns" />
    <category term="github_page" />
    <category term="domain" />
    <category term="issue" />
    <category term="custom_domain" />
    <category term="배포" />
    <category term="hexo_deploy" />
    <category term="ssh" />
    <category term="terminal" />
    <category term="cmd" />
    <category term="bash" />
    <category term="https" />
    <category term="인증서" />
    <category term="apache" />
    <category term="pm2" />
    <category term="스크랩" />
    <category term="잡담" />
    <category term="비동기" />
    <category term="asyncawait" />
    <category term="postman" />
    <category term="속도 개선" />
    <entry>
        <id>https://coding-coconut.com/2022/08/24/linux-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-https-certificate%EC%99%80-Apache2-%ED%94%84%EB%A1%9D%EC%8B%9C%ED%8C%A8%EC%8A%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/</id>
        <title>linux 서버에서 https certificate와 Apache2 프록시패스 설정하기</title>
        <link rel="alternate" href="https://coding-coconut.com/2022/08/24/linux-%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-https-certificate%EC%99%80-Apache2-%ED%94%84%EB%A1%9D%EC%8B%9C%ED%8C%A8%EC%8A%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"/>
        <content type="html">&lt;h3 id=&#34;들어가며&#34;&gt;&lt;a href=&#34;#들어가며&#34; class=&#34;headerlink&#34; title=&#34;들어가며&#34;&gt;&lt;/a&gt;들어가며&lt;/h3&gt;&lt;p&gt;인증서 발급방법은 기존에 알고있어서 문제가 되지 않았는데 아파치 설정파일 만지는 법을 까먹어서 한동안 설정파일과 씨름했다.. -.-;;&lt;br&gt;로그인한 유저가 관리자 권한일 경우 굳이 sudo를 입력하지 않아도 된다!&lt;/p&gt;
&lt;h3 id=&#34;0-apache2-를-깔려면-apt를-사용해야-하므로-업데이트가-필요&#34;&gt;&lt;a href=&#34;#0-apache2-를-깔려면-apt를-사용해야-하므로-업데이트가-필요&#34; class=&#34;headerlink&#34; title=&#34;0. apache2 를 깔려면 apt를 사용해야 하므로 업데이트가 필요&#34;&gt;&lt;/a&gt;0. apache2 를 깔려면 apt를 사용해야 하므로 업데이트가 필요&lt;/h3&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo apt update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;1-linux-전용-apache2-설치&#34;&gt;&lt;a href=&#34;#1-linux-전용-apache2-설치&#34; class=&#34;headerlink&#34; title=&#34;1. linux 전용 apache2 설치&#34;&gt;&lt;/a&gt;1. linux 전용 apache2 설치&lt;/h3&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo apt install apache2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;2-000-default-conf-편집&#34;&gt;&lt;a href=&#34;#2-000-default-conf-편집&#34; class=&#34;headerlink&#34; title=&#34;2. 000-default.conf 편집&#34;&gt;&lt;/a&gt;2. 000-default.conf 편집&lt;/h3&gt;&lt;p&gt;위치는 리눅스 우분투 서버18 기준 맨~ 위 디렉토리 /etc/apache2/site-available/000-default.conf 이다&lt;br&gt;vi 로 편집하거나 (apache2 를 처음 설치하게 되면 기본으로 파일설정 권한이 읽기전용이다 -.-;;;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;파일 권한 수정(읽기 쓰기 실행 다 허용)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo chmod 777 000-default.conf[혹은 디렉토리]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;000-default.conf 를 아래처럼 편집한 후 저장&lt;br&gt;vi 명령어를 사용해서 즉석으로 편집해도 되고 파일질라같은 ftp 응용프로그램을 이용해서 로컬에서 작성하고 덮어쓰기해도 좋다.&lt;br&gt;vi 명령어일 경우 저장하고 나가기는 esc + :wq!이다&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;#LoadModule 구문을 써 줘야 ProxyPass가 작동한다. 이거 미리 설정하면 아래 파일을 실행시키는 스크립트 작성할 필요 x&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;LoadModule proxy_module modules/mod_proxy.so&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;LoadModule proxy_http_module modules/mod_proxy_http.so&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;VirtualHost *:80&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	ServerAdmin webmaster@localhost&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	DocumentRoot /var/www/html&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	ServerName yourdomain.com&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	ServerAlias yourdomain.com&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	ProxyRequests Off&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	ProxyPreserveHost On&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;# 80으로 받으면 아래 주소로 넘긴다. 여기서의 로컬호스트는 apache가 돌아가는 컴퓨터의 로컬호스트.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;comment&#34;&gt;#주소창에서 보여지는 주소도 서버네임으로 바뀌어서 보여진다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  	ProxyPass / http://localhost:8080/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  	ProxyPassReverse / http://localhost:8080/&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	ErrorLog &lt;span class=&#34;variable&#34;&gt;$&amp;#123;APACHE_LOG_DIR&amp;#125;&lt;/span&gt;/error.log&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	CustomLog &lt;span class=&#34;variable&#34;&gt;$&amp;#123;APACHE_LOG_DIR&amp;#125;&lt;/span&gt;/access.log combined&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    RewriteEngine on&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    RewriteCond %&amp;#123;SERVER_NAME&amp;#125; =content-ad-dev.fastview.co.kr&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    RewriteRule ^ https://%&amp;#123;SERVER_NAME&amp;#125;%&amp;#123;REQUEST_URI&amp;#125; [END,NE,R=permanent]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;lt;/VirtualHost&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;3-Apache2-서비스-재가동&#34;&gt;&lt;a href=&#34;#3-Apache2-서비스-재가동&#34; class=&#34;headerlink&#34; title=&#34;3. Apache2 서비스 재가동&#34;&gt;&lt;/a&gt;3. Apache2 서비스 재가동&lt;/h3&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo service apache2 restart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;4-Snap-설치-이미-깔려-있으면-생략&#34;&gt;&lt;a href=&#34;#4-Snap-설치-이미-깔려-있으면-생략&#34; class=&#34;headerlink&#34; title=&#34;4. Snap 설치(이미 깔려 있으면 생략)&#34;&gt;&lt;/a&gt;4. Snap 설치(이미 깔려 있으면 생략)&lt;/h3&gt;&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo snap install core; sudo snap refresh core&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-Snap으로-Certbot-설치&#34;&gt;&lt;a href=&#34;#5-Snap으로-Certbot-설치&#34; class=&#34;headerlink&#34; title=&#34;5. Snap으로 Certbot 설치&#34;&gt;&lt;/a&gt;5. Snap으로 Certbot 설치&lt;/h3&gt;&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo snap install --classic certbot&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;6-Apache-사양으로-인증서-발급-apache2-서비스가-가동-중이고-80포트가-뜷려있어야-함&#34;&gt;&lt;a href=&#34;#6-Apache-사양으로-인증서-발급-apache2-서비스가-가동-중이고-80포트가-뜷려있어야-함&#34; class=&#34;headerlink&#34; title=&#34;6. Apache 사양으로 인증서 발급(apache2 서비스가 가동 중이고 80포트가 뜷려있어야 함)&#34;&gt;&lt;/a&gt;6. Apache 사양으로 인증서 발급(apache2 서비스가 가동 중이고 80포트가 뜷려있어야 함)&lt;/h3&gt;&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sudo certbot --apache&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;머라머라 나오는데 읽어보면 도메인 입력해달라는것과 인증서 만료 시 발송할 이메일좀 설정해달라는 내용&lt;br&gt;그리고.. 뭔가를 보낸다는 내용인데 이 항목은 생략해도 됨&lt;/p&gt;
&lt;p&gt;만약 과정이 꼬여서 000-default.conf를 다시 수정해야 하면, 인증서파일 재설정을 하면 된다.&lt;/p&gt;
&lt;p&gt;인증서가 이미 존재할 때 위 명령어를 입력하면 인증서 목록이 뜨는데 원하는 도메인의 번호를 입력한다.&lt;/p&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1: Attempt to reinstall this existing certificate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;해당 항목을 선택하면 Certbot의 인증서 파일(000-default-le-ssl.conf)이 다시 갱신된다.&lt;/p&gt;
&lt;h3 id=&#34;7-확인&#34;&gt;&lt;a href=&#34;#7-확인&#34; class=&#34;headerlink&#34; title=&#34;7. 확인&#34;&gt;&lt;/a&gt;7. 확인&lt;/h3&gt;&lt;p&gt;웹페이지에 접속해서 자물쇠 표시가 뜨면 성공!&lt;/p&gt;
</content>
        <category term="certbot" />
        <category term="배포" />
        <category term="https" />
        <category term="인증서" />
        <category term="apache" />
        <updated>2022-08-24T09:14:09.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2022/07/28/Hexo-%EB%B0%B0%ED%8F%AC-%EC%BB%A4%EB%A7%A8%EB%93%9C%EC%99%80-%EC%BB%A4%EC%8A%A4%ED%85%80-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%97%90-%EA%B4%80%ED%95%9C-%EC%9D%B4%EC%8A%88/</id>
        <title>Hexo 배포 커맨드와 커스텀 도메인에 관한 이슈</title>
        <link rel="alternate" href="https://coding-coconut.com/2022/07/28/Hexo-%EB%B0%B0%ED%8F%AC-%EC%BB%A4%EB%A7%A8%EB%93%9C%EC%99%80-%EC%BB%A4%EC%8A%A4%ED%85%80-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%97%90-%EA%B4%80%ED%95%9C-%EC%9D%B4%EC%8A%88/"/>
        <content type="html">&lt;h3 id=&#34;문제점&#34;&gt;&lt;a href=&#34;#문제점&#34; class=&#34;headerlink&#34; title=&#34;문제점&#34;&gt;&lt;/a&gt;문제점&lt;/h3&gt;&lt;p&gt; 기존 도메인에서 블로그 전용 도메인을 구매하고, 깃허브 페이지에 연결해 놓았었는데&lt;br&gt;Hexo로 만든 블로그 프로젝트에서 &lt;code&gt;hexo deploy&lt;/code&gt; 커맨드를 이용해 배포하면&lt;br&gt;깃허브 페이지의 퍼블리싱된 커스텀 도메인이 초기화가 되는 이슈가 발생했다.&lt;/p&gt;
&lt;h3 id=&#34;해결&#34;&gt;&lt;a href=&#34;#해결&#34; class=&#34;headerlink&#34; title=&#34;해결&#34;&gt;&lt;/a&gt;해결&lt;/h3&gt;&lt;p&gt;이를 해결하려면 hexo 의 블로그 프로젝트 source 폴더에&lt;br&gt;CNAME 파일을 생성하고, 안에 퍼블리싱할 커스텀 도메인을 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/postimg/cname_file.png&#34; alt=&#34;cname_file&#34;&gt;&lt;/p&gt;
&lt;p&gt;이후 &lt;code&gt;hexo deploy&lt;/code&gt; 커맨드를 입력하여 배포해도 깃허브 페이지의 커스텀 도메인이 해제되지 않는다.&lt;/p&gt;
</content>
        <category term="hexo" />
        <category term="github_page" />
        <category term="issue" />
        <category term="custom_domain" />
        <category term="배포" />
        <category term="hexo_deploy" />
        <updated>2022-07-28T00:56:12.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2022/07/21/Github-Page%EC%97%90-%EC%BB%A4%EC%8A%A4%ED%85%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0/</id>
        <title>Github Page에 커스텀 도메인 연결하기</title>
        <link rel="alternate" href="https://coding-coconut.com/2022/07/21/Github-Page%EC%97%90-%EC%BB%A4%EC%8A%A4%ED%85%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0/"/>
        <content type="html">&lt;h1 id=&#34;Github-Page에-커스텀-도메인-연결하기&#34;&gt;&lt;a href=&#34;#Github-Page에-커스텀-도메인-연결하기&#34; class=&#34;headerlink&#34; title=&#34;Github Page에 커스텀 도메인 연결하기&#34;&gt;&lt;/a&gt;Github Page에 커스텀 도메인 연결하기&lt;/h1&gt;&lt;p&gt;방법은 다음과 같다.&lt;/p&gt;
&lt;h3 id=&#34;도메인을-구입한-사이트에서-깃허브-리포지토리-주소를-CNAME으로-추가-또는-변경해주기&#34;&gt;&lt;a href=&#34;#도메인을-구입한-사이트에서-깃허브-리포지토리-주소를-CNAME으로-추가-또는-변경해주기&#34; class=&#34;headerlink&#34; title=&#34;도메인을 구입한 사이트에서 깃허브 리포지토리 주소를 CNAME으로 추가 또는 변경해주기&#34;&gt;&lt;/a&gt;도메인을 구입한 사이트에서 깃허브 리포지토리 주소를 CNAME으로 추가 또는 변경해주기&lt;/h3&gt;&lt;p&gt;도메인을 구입한 사이트에서 있어야 할 레코드는 다음과 같다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;레코드명&lt;/th&gt;
&lt;th&gt;이름&lt;/th&gt;
&lt;th&gt;데이터&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;CNAME&lt;/td&gt;
&lt;td&gt;www&lt;/td&gt;
&lt;td&gt;[yourRepo].github.io&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;185.199.108.153&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;185.199.109.153&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;185.199.110.153&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;185.199.111.153&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;네임서버는 따로 이관하지 않아도 된다.&lt;/p&gt;
&lt;h3 id=&#34;블로그로-서비스되고있는-깃허브-페이지의-리포지토리-gt-Setting-gt-Page&#34;&gt;&lt;a href=&#34;#블로그로-서비스되고있는-깃허브-페이지의-리포지토리-gt-Setting-gt-Page&#34; class=&#34;headerlink&#34; title=&#34;블로그로 서비스되고있는 깃허브 페이지의 리포지토리 =&amp;gt; Setting =&amp;gt; Page&#34;&gt;&lt;/a&gt;블로그로 서비스되고있는 깃허브 페이지의 리포지토리 =&amp;gt; Setting =&amp;gt; Page&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/img/postimg/custom_domain.png&#34; alt=&#34;커스텀 도메인&#34;&gt;&lt;/p&gt;
&lt;p&gt;save를 누르면 위에 등록한 DNS정보가 모두 올바를 경우 해당 주소로 퍼블리시되었다는 알람을 띄운다.&lt;/p&gt;
&lt;p&gt;아래 체크박스를 보면 알 수 있지만 GithubPage 특성상 https 옵션을 활성화할 수 있다.&lt;/p&gt;
&lt;p&gt;도메인으로 접속했을 때 깃허브 페이지가 뜨면 성공!&lt;/p&gt;
</content>
        <category term="dns" />
        <category term="github_page" />
        <category term="domain" />
        <updated>2022-07-21T08:20:52.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2022/06/10/Hexo-%ED%85%8C%EB%A7%88-%EB%A7%8C%EB%93%A4%EA%B8%B0/</id>
        <title>Hexo 테마 만들기</title>
        <link rel="alternate" href="https://coding-coconut.com/2022/06/10/Hexo-%ED%85%8C%EB%A7%88-%EB%A7%8C%EB%93%A4%EA%B8%B0/"/>
        <content type="html">&lt;h1 id=&#34;Hexo-테마-구축하기&#34;&gt;&lt;a href=&#34;#Hexo-테마-구축하기&#34; class=&#34;headerlink&#34; title=&#34;Hexo 테마 구축하기&#34;&gt;&lt;/a&gt;Hexo 테마 구축하기&lt;/h1&gt;&lt;h4 id=&#34;들어가며&#34;&gt;&lt;a href=&#34;#들어가며&#34; class=&#34;headerlink&#34; title=&#34;들어가며&#34;&gt;&lt;/a&gt;들어가며&lt;/h4&gt;&lt;p&gt;Hexo 에서 기본적으로 제공하는 기본값 레이아웃 icarus의 소스가 많이 도움이 되었다.&lt;br&gt;&lt;br&gt;Hexo 는 블로그 ‘프레임워크’ 이며, 공식 문서에서는 helper라는 이름으로 렌더링 스크립트도 제공한다. 용어가 생소해서 많이 헤맸던 기억이 난다.&lt;br&gt;헬퍼에서 제공하는 스크립트는 서버사이드 혹은 클라이언트 사이드 렌더링처럼 뷰 엔진 파일 위에서 사용할 수 있다. 해외에서 안내하는 방법대로 테마를 만들어보고, 정리해보고자 이렇게 게시물을 작성하게 되었다.&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;목차&#34;&gt;&lt;a href=&#34;#목차&#34; class=&#34;headerlink&#34; title=&#34;목차&#34;&gt;&lt;/a&gt;목차&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;테마 폴더 만들기&lt;/li&gt;
&lt;li&gt;layout 파일 만들기&lt;/li&gt;
&lt;li&gt;기본 페이지 추가하기&lt;ul&gt;
&lt;li&gt;index&lt;/li&gt;
&lt;li&gt;archive&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;부분 렌더링(페이지 쪼개기)&lt;/li&gt;
&lt;li&gt;정적 소스 불러오기&lt;/li&gt;
&lt;li&gt;만든 테마 적용하기&lt;/li&gt;
&lt;li&gt;테마가 적용된 블로그 배포하기&lt;/li&gt;
&lt;li&gt;테마 만들기 심화&lt;ul&gt;
&lt;li&gt;부가 페이지 만들기&lt;/li&gt;
&lt;li&gt;댓글 위젯 달기(utterances)&lt;/li&gt;
&lt;li&gt;손수 위젯 만들기&lt;/li&gt;
&lt;li&gt;커스텀 404 페이지(github)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;테마-폴더-만들기&#34;&gt;&lt;a href=&#34;#테마-폴더-만들기&#34; class=&#34;headerlink&#34; title=&#34;테마 폴더 만들기&#34;&gt;&lt;/a&gt;테마 폴더 만들기&lt;/h2&gt;&lt;p&gt;Hexo init을 실행하고 나서, 프로젝트의 루트 경로 아래에 themes 폴더를 만든다.&lt;/p&gt;
&lt;p&gt;themes 폴더 하위에 테마 이름을 짓고 영문명으로 폴더를 생성한다. ex)your-theme-name&lt;/p&gt;
&lt;p&gt;your-theme-name 폴더 하위에도 _config.yml 파일을 만든다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hexo는 _config.yml을 환경변수 겸용 클라이언트딴 전역변수처럼 사용할 수 있는데, &lt;br&gt;&lt;br&gt;테마 하위에 있는 _config.yml은 이 테마에서만 특별하게 적용되는 환경변수값을 지정해서 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[your-theme-name]폴더 하위에 렌더링 형태를 결정할 layout 폴더와, 테마의 정적 리소스들이 들어갈 source 폴더를 만든다.&lt;/p&gt;
&lt;h4 id=&#34;요약&#34;&gt;&lt;a href=&#34;#요약&#34; class=&#34;headerlink&#34; title=&#34;요약&#34;&gt;&lt;/a&gt;요약&lt;/h4&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;themes 폴더 &amp;gt; [your-theme-name] 폴더 생성&lt;/li&gt;
&lt;li&gt;하위에 layout/source 폴더, _config.yml 만들기&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;layout-파일-만들기&#34;&gt;&lt;a href=&#34;#layout-파일-만들기&#34; class=&#34;headerlink&#34; title=&#34;layout 파일 만들기&#34;&gt;&lt;/a&gt;layout 파일 만들기&lt;/h2&gt;&lt;p&gt;폴더 구조를 잡았으면, [yout-theme-name]/layout 폴더 하위에 이제 페이지 골격을 이루는 파일을 만들어야 한다.&lt;br&gt;Hexo는 서버사이드 렌더링이나 클라이언트 사이드 렌더링을 할 때처럼 부분 렌더링을 지원한다.&lt;br&gt;이는 ejs나 pug 같은 뷰 엔진을 통해 이루어진다.&lt;/p&gt;
&lt;p&gt;특히 layout 파일은 테마의 전반적인 레이아웃을 결정한다.&lt;br&gt;메인 페이지, 블로그 페이지, 아카이브 페이지로 이동할 때, layout 파일 구조에 베이스를 잡고 하위에 페이지를 그린다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;페이지별로 아예 다른 레이아웃을 적용하고 싶다면, 상위로 먼저 참조하는 layout을 이에 맞게 작성해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;테마 폴더의 구조를 잡았으면 이제 렌더링할 뷰 엔진을 선택한다.&lt;br&gt;node.js를 하는 사람이라면 익숙한 뷰 엔진인 ejs 도 채택할 수 있다.&lt;br&gt;ejs를 사용한다면, 이에 맞는 layout 파일을 만든다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/postimg/layout01.png&#34; alt=&#34;layout 파일 구조&#34;&gt;&lt;/p&gt;
&lt;p&gt;body 부분에 페이지가 이동될 때 페이지에 맞는 부분 레이아웃이 그려진다.&lt;/p&gt;
&lt;h2 id=&#34;기본-페이지-추가하기&#34;&gt;&lt;a href=&#34;#기본-페이지-추가하기&#34; class=&#34;headerlink&#34; title=&#34;기본 페이지 추가하기&#34;&gt;&lt;/a&gt;기본 페이지 추가하기&lt;/h2&gt;&lt;p&gt;layout 파일을 작성했다면, 페이지의 레이아웃을 추가한다.&lt;/p&gt;
&lt;h3 id=&#34;index&#34;&gt;&lt;a href=&#34;#index&#34; class=&#34;headerlink&#34; title=&#34;index&#34;&gt;&lt;/a&gt;index&lt;/h3&gt;&lt;p&gt;사이트에 진입했을 때, 가장 먼저 보여지는 페이지의 레이아웃은 index 페이지 레이아웃을 따른다.&lt;/p&gt;
&lt;h3 id=&#34;archive&#34;&gt;&lt;a href=&#34;#archive&#34; class=&#34;headerlink&#34; title=&#34;archive&#34;&gt;&lt;/a&gt;archive&lt;/h3&gt;&lt;p&gt;아카이브 페이지는 주제별 카테고리 및 기간별 아카이브를 선택했을 때 그려지는 레이아웃이다.&lt;/p&gt;
&lt;h2 id=&#34;부분-렌더링-페이지-쪼개기&#34;&gt;&lt;a href=&#34;#부분-렌더링-페이지-쪼개기&#34; class=&#34;headerlink&#34; title=&#34;부분 렌더링(페이지 쪼개기)&#34;&gt;&lt;/a&gt;부분 렌더링(페이지 쪼개기)&lt;/h2&gt;&lt;p&gt;Hexo는 앞서 말했듯이 뷰 엔진을 통한 부분 렌더링을 지원한다.&lt;br&gt;페이지 레이아웃에 통째로 작성해도 좋지만, 반복되는 구조 등이 있다면 partial 이라고 컴포넌트화 해서 위젯 붙이듯 붙여넣는 방법을 채택할 수도 있다.&lt;br&gt;이는 _partial 폴더 하위에 작성해서, partial 키워드로 렌더링 코드를 작성하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/postimg/folder_structure.png&#34; alt=&#34;테마 폴더의 내부 구조&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/postimg/layout01.png&#34; alt=&#34;작성한 partial 을 다음처럼 적용한다&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;정적-소스-불러오기&#34;&gt;&lt;a href=&#34;#정적-소스-불러오기&#34; class=&#34;headerlink&#34; title=&#34;정적 소스 불러오기&#34;&gt;&lt;/a&gt;정적 소스 불러오기&lt;/h2&gt;&lt;p&gt;source 폴더는 프로젝트의 루트에도 있고, 테마 내부에도 있다.&lt;/p&gt;
&lt;p&gt;테마 내부의 source 폴더는 블로그 포스팅에 사용되는 img 나 css, js 파일과 같은 정적 리소스를 두는 데에 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/postimg/theme_source_folder.png&#34; alt=&#34;테마 내부의 source 폴더 안에는 정적 리소스가 들어간다&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;만든-테마-적용하기&#34;&gt;&lt;a href=&#34;#만든-테마-적용하기&#34; class=&#34;headerlink&#34; title=&#34;만든 테마 적용하기&#34;&gt;&lt;/a&gt;만든 테마 적용하기&lt;/h2&gt;&lt;p&gt;테마의 _config.yml이 아닌 프로젝트 루트 위치의 _config.yml에서 theme 명을&lt;br&gt;작성해 두었던 theme 명으로 변경한다.&lt;br&gt;변경사항을 저장하고 Hexo server를 가동하면 적용된 테마를 확인할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;테마가-적용된-블로그-배포하기-github&#34;&gt;&lt;a href=&#34;#테마가-적용된-블로그-배포하기-github&#34; class=&#34;headerlink&#34; title=&#34;테마가 적용된 블로그 배포하기(github)&#34;&gt;&lt;/a&gt;테마가 적용된 블로그 배포하기(github)&lt;/h2&gt;&lt;p&gt;Hexo에는 배포 자동화 플러그인이 있다.&lt;br&gt;github에 배포하려면 hexo-deploy-git 플러그인을 사용하자.&lt;br&gt;프로젝트 루트의 _config.yml에서 deploy관련 설정을 작성해준다.&lt;br&gt;&lt;img src=&#34;/img/postimg/github_deploy_yml.png&#34; alt=&#34;깃허브 배포 yml 설정&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;테마-만들기-심화&#34;&gt;&lt;a href=&#34;#테마-만들기-심화&#34; class=&#34;headerlink&#34; title=&#34;테마 만들기 심화&#34;&gt;&lt;/a&gt;테마 만들기 심화&lt;/h2&gt;&lt;h3 id=&#34;부가-페이지-만들기&#34;&gt;&lt;a href=&#34;#부가-페이지-만들기&#34; class=&#34;headerlink&#34; title=&#34;부가 페이지 만들기&#34;&gt;&lt;/a&gt;부가 페이지 만들기&lt;/h3&gt;&lt;p&gt;hexo new page [페이지명] 커맨드를 하면 프로젝트 루트의 source 폴더 내부에 [페이지명]으로 된 폴더가 생기는데, 페이지 주소를 받기 위해 index.md 가 내장되어 있다.&lt;/p&gt;
&lt;p&gt;프로파일처럼 아무 내용이 없더라도, 페이지는 만들어지며 .md 의 yml 부분에서 레이아웃을 설정해주지 않으면, 테마의 index.ejs의 레이아웃으로 적용된다.&lt;/p&gt;
&lt;p&gt;theme에서 부가적으로 만들 페이지의 레이아웃을 설정해준다.&lt;/p&gt;
&lt;p&gt;예시로 guest 나 prologue 등 부가적인 ejs를 생성한다.&lt;/p&gt;
&lt;p&gt;해당 테마는 guest나 prologue라는 이름의 레이아웃이 생기게 되며,&lt;br&gt;프로젝트 루트 폴더/source 내부의 페이지 이름으로 된 폴더 내부의 index.md의 layout 값을&lt;br&gt;해당 페이지의 layout 이름으로 지정해준다.&lt;/p&gt;
&lt;p&gt;서버를 가동하면 페이지에 레이아웃이 적용된 걸 확인할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;댓글-위젯-달기-utterances&#34;&gt;&lt;a href=&#34;#댓글-위젯-달기-utterances&#34; class=&#34;headerlink&#34; title=&#34;댓글 위젯 달기(utterances)&#34;&gt;&lt;/a&gt;댓글 위젯 달기(utterances)&lt;/h3&gt;&lt;p&gt;포스트 페이지 아래에 utterances 플러그인을 삽입한다.&lt;/p&gt;
&lt;p&gt;git 이슈와 연동하는 권한을 utterances에게 부여해야 한다.&lt;/p&gt;
&lt;p&gt;Hexo 게시물의 퍼머링크와 해당 플러그인을 바인딩하면 각 포스트에 댓글을 달 때마다&lt;br&gt;포스트별로 이슈가 생성되고, 알람을 받아볼 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;손수-위젯-만들기&#34;&gt;&lt;a href=&#34;#손수-위젯-만들기&#34; class=&#34;headerlink&#34; title=&#34;손수 위젯 만들기&#34;&gt;&lt;/a&gt;손수 위젯 만들기&lt;/h3&gt;&lt;p&gt;partial 키워드가 부분 렌더링하는 걸 이용하여 위젯을 만들 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최근 포스트&lt;/li&gt;
&lt;li&gt;포스트의 내용 트래커&lt;/li&gt;
&lt;li&gt;카테고리 메뉴&lt;/li&gt;
&lt;li&gt;태그 클라우드 메뉴 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;커스텀-404-페이지-github&#34;&gt;&lt;a href=&#34;#커스텀-404-페이지-github&#34; class=&#34;headerlink&#34; title=&#34;커스텀 404 페이지(github)&#34;&gt;&lt;/a&gt;커스텀 404 페이지(github)&lt;/h3&gt;&lt;p&gt;배포를 깃허브에 하는 경우 source 폴더 바로 아래에 404.html 을 만들어 넣어두면&lt;br&gt;github에서 링크를 찾지 못할 때마다 404.html 로 리디렉션시킨다.&lt;/p&gt;
&lt;p&gt;잘 꾸며서 넣어두면 따로 라우팅을 설정할 필요가 없어 편리하다.&lt;/p&gt;
</content>
        <category term="hexo" />
        <updated>2022-06-10T08:03:21.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2022/05/20/SSH%ED%82%A4%EB%A1%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%95%98%EB%8A%94-%EB%B2%95/</id>
        <title>SSH키로 로그인하는 법</title>
        <link rel="alternate" href="https://coding-coconut.com/2022/05/20/SSH%ED%82%A4%EB%A1%9C-%EB%A1%9C%EA%B7%B8%EC%9D%B8%ED%95%98%EB%8A%94-%EB%B2%95/"/>
        <content type="html">&lt;h2 id=&#34;SSH키로-로그인하는-법&#34;&gt;&lt;a href=&#34;#SSH키로-로그인하는-법&#34; class=&#34;headerlink&#34; title=&#34;SSH키로 로그인하는 법&#34;&gt;&lt;/a&gt;SSH키로 로그인하는 법&lt;/h2&gt;&lt;h3 id=&#34;SSH-키-생성하기&#34;&gt;&lt;a href=&#34;#SSH-키-생성하기&#34; class=&#34;headerlink&#34; title=&#34;SSH 키 생성하기&#34;&gt;&lt;/a&gt;SSH 키 생성하기&lt;/h3&gt;&lt;p&gt;깃허브나 벌쳐 인증서버/원격 데이터베이스에 접속할 때 키로그인을 필요로 하기도 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;키 생성하기&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight cmd&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;ssh-keygen&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;모든 설정 기본값으로 하면 내 컴퓨터/사용자 폴더/.ssh폴더(숨겨진 폴더)안에 다음처럼 rsa 키가 생성된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id_rsa&lt;/li&gt;
&lt;li&gt;id_rsa.pub&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;키-파일-등록&#34;&gt;&lt;a href=&#34;#키-파일-등록&#34; class=&#34;headerlink&#34; title=&#34;키 파일 등록&#34;&gt;&lt;/a&gt;키 파일 등록&lt;/h3&gt;&lt;p&gt;ssh 를 이용해서 로그인하려면 이전 과정에서 생성된 두가지 키가 필요하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id_rsa (클라이언트 피시가 가지고 있을 프라이빗 키. 이걸로 로그인함!)&lt;/li&gt;
&lt;li&gt;id_rsa.pub (호스트에 등록할 퍼블릭 키. 긁어서 호스트에 등록해야한다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;id_rsa는 다른 이름이거나 확장자가 &lt;code&gt;.ppk&lt;/code&gt; 또는 &lt;code&gt;.pem&lt;/code&gt;일 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;.ssh 안에 프라이빗 키를 집어넣고, 퍼블릭 키는 파일을 열어 내부를 긁어서 호스트에 등록한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;SSH-원격-접속-Config-파일-작성&#34;&gt;&lt;a href=&#34;#SSH-원격-접속-Config-파일-작성&#34; class=&#34;headerlink&#34; title=&#34;SSH 원격 접속 Config 파일 작성&#34;&gt;&lt;/a&gt;SSH 원격 접속 Config 파일 작성&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;터미널 원격 ssh 접속 시 간편 커맨드를 위한 .ssh/config 파일을 설정한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;Host [ConnectionName]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	HostName [HostIP]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	User [HostLoginID]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	IdentityFile ~/.ssh/[YOUR_PRIVATE_KEY_FILE]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;위처럼 만들어 저장해 놓으면&lt;/p&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;ssh [ConnectionName]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;으로 간편하게 접속할 수 있다.&lt;/p&gt;
&lt;p&gt;키 파일 위치만 올바르다면 별도의 패스워드를 요구하진 않는다.&lt;/p&gt;
&lt;h3 id=&#34;기타-파일변환&#34;&gt;&lt;a href=&#34;#기타-파일변환&#34; class=&#34;headerlink&#34; title=&#34;기타 파일변환&#34;&gt;&lt;/a&gt;기타 파일변환&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;putty .ppk파일을 제네릭한 .pem으로 변환(윈도즈 putty가 있으면 ppk 그대로 사용해도됨)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Mac 인 경우(선제 homebrew 설치 필요)&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;brew install putty &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;puttygen 원본.ppk -O private-openssh -o 내보낼.pem&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;Windows인 경우 putty-keygen exe를 이용한다.&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="ssh" />
        <category term="terminal" />
        <category term="cmd" />
        <category term="bash" />
        <updated>2022-05-20T08:44:10.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2022/05/20/pm2%EC%99%80-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%ED%99%94/</id>
        <title>pm2와 클러스터화</title>
        <link rel="alternate" href="https://coding-coconut.com/2022/05/20/pm2%EC%99%80-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%ED%99%94/"/>
        <content type="html">&lt;h2 id=&#34;클러스터화-가동-설정-및-디버깅&#34;&gt;&lt;a href=&#34;#클러스터화-가동-설정-및-디버깅&#34; class=&#34;headerlink&#34; title=&#34;클러스터화 가동 설정 및 디버깅&#34;&gt;&lt;/a&gt;클러스터화 가동 설정 및 디버깅&lt;/h2&gt;&lt;p&gt;Node.js의 루트 바로 아래에 있는 인덱스 파일들은 package.json 설정 등을 통하면 멀티스레드로 실행할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;package.json 파일 설정과 pm2를 이용하여 별개의 프로그램을 클러스터화 가동한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;1-pm2-npm-모듈-글로벌-옵션으로-깔기-클러스터-작동-확인을-위한-도구&#34;&gt;&lt;a href=&#34;#1-pm2-npm-모듈-글로벌-옵션으로-깔기-클러스터-작동-확인을-위한-도구&#34; class=&#34;headerlink&#34; title=&#34;1. pm2 npm 모듈 글로벌 옵션으로 깔기(클러스터 작동 확인을 위한 도구)&#34;&gt;&lt;/a&gt;1. pm2 npm 모듈 글로벌 옵션으로 깔기(클러스터 작동 확인을 위한 도구)&lt;/h3&gt;&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;npm install pm2 -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;2-클러스터화-파일-작성&#34;&gt;&lt;a href=&#34;#2-클러스터화-파일-작성&#34; class=&#34;headerlink&#34; title=&#34;2. 클러스터화 파일 작성&#34;&gt;&lt;/a&gt;2. 클러스터화 파일 작성&lt;/h3&gt;&lt;p&gt;  각 클러스터의 dev 실행 명령어 지정 및 클러스터화 시동 명령어 지정(package.json)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;package.json 작성 예제. daum/blog/post는 각기 실행할 별개의 index.ts파일이라고 보면 됨.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&amp;quot;scripts&amp;quot;:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;start:cluster&amp;quot;: &amp;quot;pm2-runtime pm2.config.js&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;dev:post&amp;quot;: &amp;quot;nodemon --legacy-watch --watch ./ --exec &amp;#x27;npx&amp;#x27; ts-node -r tsconfig-paths/register ./src/post.ts&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;dev:blog&amp;quot;: &amp;quot;nodemon --legacy-watch --watch ./ --exec &amp;#x27;npx&amp;#x27; ts-node -r tsconfig-paths/register ./src/blog.ts&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;dev:daum&amp;quot;: &amp;quot;nodemon --legacy-watch --watch ./ --exec &amp;#x27;npx&amp;#x27; ts-node -r tsconfig-paths/register ./src/daum.ts&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;dev&amp;quot;: &amp;quot;npm run dev:blog &amp;amp; npm run dev:daum &amp;amp; npm run dev:post&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;quot;build&amp;quot;: &amp;quot;tsc -p tsconfig.json &amp;amp;&amp;amp; tsc-alias&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;pm2.config.js 작성 예제. 클러스터화를 할 설정파일들을 지정한다. 인스턴스 갯수만큼 생성이 됨.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;module&lt;/span&gt;.exports=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    apps:[&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#123; &lt;span class=&#34;attr&#34;&gt;name&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;post&amp;quot;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;script&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;./dist/post.js&amp;quot;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;instances&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;exec_mode&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;cluster&amp;quot;&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#123; &lt;span class=&#34;attr&#34;&gt;name&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;blog&amp;quot;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;script&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;./dist/blog.js&amp;quot;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;instances&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;exec_mode&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;cluster&amp;quot;&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#123; &lt;span class=&#34;attr&#34;&gt;name&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;daum&amp;quot;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;script&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;./dist/daum.js&amp;quot;&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;instances&lt;/span&gt;: &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;attr&#34;&gt;exec_mode&lt;/span&gt;: &lt;span class=&#34;string&#34;&gt;&amp;quot;cluster&amp;quot;&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-빌드하기&#34;&gt;&lt;a href=&#34;#3-빌드하기&#34; class=&#34;headerlink&#34; title=&#34;3. 빌드하기&#34;&gt;&lt;/a&gt;3. 빌드하기&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;타입스크립트 파일들이 js로 빌드된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;npm run build&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;4-클러스터-가동&#34;&gt;&lt;a href=&#34;#4-클러스터-가동&#34; class=&#34;headerlink&#34; title=&#34;4. 클러스터 가동&#34;&gt;&lt;/a&gt;4. 클러스터 가동&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;package.json에서 선제 명령어 설정을 해줘야 함&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;npm run start:cluster&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;5-이후-디버깅은-pm2-에서-할-수-있음&#34;&gt;&lt;a href=&#34;#5-이후-디버깅은-pm2-에서-할-수-있음&#34; class=&#34;headerlink&#34; title=&#34;5. 이후 디버깅은 pm2 에서 할 수 있음&#34;&gt;&lt;/a&gt;5. 이후 디버깅은 pm2 에서 할 수 있음&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;가동되고 있는 클러스터 확인&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;pm2 list&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;클러스터 상세내역 확인(방향키로 조정)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;pm2 monit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;클러스터 가동 취소&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;npm run start:cluster 명령어를 쳤던 커맨드창 ctrl+c &lt;/p&gt;
&lt;p&gt;이렇게 취소하면 pm2 list 했을 때 생성되었던 클러스터들이 사라진 것을 볼 수 있다.&lt;/p&gt;
</content>
        <category term="pm2" />
        <updated>2022-05-20T07:51:12.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2022/01/27/%ED%95%A8%EC%88%98%EC%9D%98-%EB%B9%84%EB%8F%99%EA%B8%B0%ED%99%94%EC%99%80-async-%ED%82%A4%EC%9B%8C%EB%93%9C/</id>
        <title>함수의 비동기화와 async 키워드</title>
        <link rel="alternate" href="https://coding-coconut.com/2022/01/27/%ED%95%A8%EC%88%98%EC%9D%98-%EB%B9%84%EB%8F%99%EA%B8%B0%ED%99%94%EC%99%80-async-%ED%82%A4%EC%9B%8C%EB%93%9C/"/>
        <content type="html">&lt;h1 id=&#34;함수의-비동기화&#34;&gt;&lt;a href=&#34;#함수의-비동기화&#34; class=&#34;headerlink&#34; title=&#34;함수의 비동기화&#34;&gt;&lt;/a&gt;함수의 비동기화&lt;/h1&gt;&lt;p&gt;기존 async await 를 단순히 비동기를 순차적으로 처리하는 데에만 이용하다가,&lt;br&gt;실무상 비동기로 함수를 처리해야 할 일이 생겼다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;일반적인 자바스크립트 함수&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; (&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//그냥 함수&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;자바스크립트 특성상 비동기 함수의 경우 일반 함수에서 호출 시 실행하라는 오더만 내리고 바로 다음 항목을 진행한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;비동기를 동기적으로 처리할 때, async await 의 사용법.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;somePromiseFunc&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;span class=&#34;comment&#34;&gt;//Promise 반환 함수인 somePromiseFunc.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;Promise&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;(&lt;span class=&#34;params&#34;&gt;resolve,reject&lt;/span&gt;)=&amp;gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         &lt;span class=&#34;comment&#34;&gt;//input do something..&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         resolve(async_logic_result)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt;(err)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;         reject(err)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;span class=&#34;comment&#34;&gt;//async await 의 일반적인 사용.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; result = &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; somePromiseFunc() &lt;span class=&#34;comment&#34;&gt;//비동기 함수의 응답을 받기 위해 await를 사용&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//do other func&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;async await 는 비동기 처리함수를 동기적으로 처리할 때 쓰이는 문법이다.&lt;br&gt;await는 async를 선언한 함수 내부에서만 쓸 수 있으며, Promise 를 반환하는 함수에 써서 result 변수에 resolve 내부에 들어가있는 결과값을 받을 수 있다.&lt;/p&gt;
&lt;p&gt;평소에 이렇게 비동기를 동기적으로 수행처리하는 과정만 생각하는게 주인데, 이번에는 업무상 응답속도를 줄이기 위해 의도적으로 함수를 비동기화해야하는 것이었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;실무에선 300줄 이상의 무거운 쿼리는 수행하라는 명령만 내리고, 문자열처럼 생성이 빠른 것들은 빨리 생성해서 바로 200 응답을 전송하길 원했다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 방법을 찾는 과정에서 각 실행 방법의 응답속도를 비교했고, 더불어&lt;br&gt;async-await 키워드의 새로운 기능을 알게 되었다.&lt;/p&gt;
&lt;br&gt;

&lt;h1 id=&#34;속도-비교&#34;&gt;&lt;a href=&#34;#속도-비교&#34; class=&#34;headerlink&#34; title=&#34;속도 비교&#34;&gt;&lt;/a&gt;속도 비교&lt;/h1&gt;&lt;h2 id=&#34;1-일반-실행&#34;&gt;&lt;a href=&#34;#1-일반-실행&#34; class=&#34;headerlink&#34; title=&#34;1. 일반 실행&#34;&gt;&lt;/a&gt;1. 일반 실행&lt;/h2&gt;&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;someHeavyFunc&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//무거운 쿼리 로직. query를 때릴 때 사용하는 모듈 자체는 비동기식으로 작동한다.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;callAsyncFunc&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; fast_key = otherModule.keyMaker(someInput); &lt;span class=&#34;comment&#34;&gt;//빠른 실행이 가능한 함수&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    someHeavyFunc()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; fast_answer=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        key:fast_key&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; fast_answer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;javascript는 기본적으로 비동기로 작동한다고 하지 않았었나..? 하지만 Postman과 console.log로 각 함수 실행과정과 응답속도를 테스트한 결과, 200 응답 뒤에 무거운 함수가 실행되는 경우는 없었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/postimg/default_do.png&#34; alt=&#34;default_do&#34;&gt;&lt;br&gt;거진.. 요청당 약 1초가 걸린다. 어마무시하다.&lt;/p&gt;
&lt;h2 id=&#34;2-setTimeout-함수&#34;&gt;&lt;a href=&#34;#2-setTimeout-함수&#34; class=&#34;headerlink&#34; title=&#34;2. setTimeout 함수&#34;&gt;&lt;/a&gt;2. setTimeout 함수&lt;/h2&gt;&lt;p&gt;두 번째로는 비동기 함수의 개념을 배울 때 주로 사용하는 setTimeout으로 테스트하였다.&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;someHeavyFunc&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//무거운 쿼리 로직..&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;callAsyncFunc&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; fast_key = otherModule.keyMaker(someInput); &lt;span class=&#34;comment&#34;&gt;//빠른 실행이 가능한 함수&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;setTimeout&lt;/span&gt;(&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        someHeavyFunc()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;,&lt;span class=&#34;number&#34;&gt;50&lt;/span&gt;) &lt;span class=&#34;comment&#34;&gt;//비동기 처리를 위해서는 어쩔 수 없나...? 근데 진짜 이렇게?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; fast_answer=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        key:fast_key&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; fast_answer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;async 키워드를 함수 앞에 붙인다는 게 무슨 뜻인지 제대로 알지 못해서 생긴 폐해다(…)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/postimg/settimeout_do.png&#34; alt=&#34;settimeout_do&#34;&gt;&lt;br&gt;응답속도가 많이 줄었다. setTimeOut 함수가 비동기 함수인 걸 알고 return을 먼저 보내고 무거운 함수를 실행한 것이다. 속도 개선은 되었지만, 당연스럽게도 setTimeOut함수를 사용하면 초반지연이 발생한다.&lt;/p&gt;
&lt;p&gt;앞서 실험했던 일반 실행과 비교해봤을 때, 이는 js가 봤을 때 함수가 비동기임을 몰라서 생기는 상황인 것 같았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그러면 어떻게 비동기 함수인걸 알려줘야할까?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;답은 async-await 페어 중 async에 있었다.&lt;/p&gt;
&lt;h2 id=&#34;3-async-키워드&#34;&gt;&lt;a href=&#34;#3-async-키워드&#34; class=&#34;headerlink&#34; title=&#34;3. async 키워드&#34;&gt;&lt;/a&gt;3. async 키워드&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;async 키워드는 함수를 비동기 취급한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;someHeavyFunc&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;comment&#34;&gt;//무거운 쿼리 로직..&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;callAsyncFunc&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; fast_key = otherModule.keyMaker(someInput); &lt;span class=&#34;comment&#34;&gt;//빠른 실행이 가능한 함수&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    someHeavyFunc()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; fast_answer=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        key:fast_key&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; fast_answer&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;무거운 함수 앞에 async를 붙이고, 무거운 함수를 호출하는 함수는 async 키워드를 붙이지 않는다.&lt;br&gt;async 키워드를 붙이지 않았으니, await도 쓸 수 없다.&lt;br&gt;결과는 어떨까?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/postimg/async_do.png&#34; alt=&#34;async_do&#34;&gt;&lt;/p&gt;
&lt;p&gt;성공이다! 원하는 응답도 제대로 가져온다.&lt;/p&gt;
&lt;h1 id=&#34;응용&#34;&gt;&lt;a href=&#34;#응용&#34; class=&#34;headerlink&#34; title=&#34;응용&#34;&gt;&lt;/a&gt;응용&lt;/h1&gt;&lt;p&gt;… 그러면 특정 부분은 비동기로 수행하고 비동기 함수끼리는 동기적으로 처리하고 싶을 때, 이렇게 하면 된다.&lt;/p&gt;
&lt;figure class=&#34;highlight javascript&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;caller&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;span class=&#34;comment&#34;&gt;//caller는 일반 함수&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; faster = doMakeFaster() &lt;span class=&#34;comment&#34;&gt;//일반 함수&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;doAsync&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;span class=&#34;comment&#34;&gt;//비동기로 묶어서 처리할 랩퍼를 선언&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;let&lt;/span&gt; result1= &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; someAsyncFunc() &lt;span class=&#34;comment&#34;&gt;//비동기 함수를 순차적으로 시행&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;await&lt;/span&gt; someAsyncFunc2(result1) &lt;span class=&#34;comment&#34;&gt;//비동기 함수를 순차적으로 시행&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    doAsync() &lt;span class=&#34;comment&#34;&gt;//비동기로 시행&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; faster;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;faster 먼저 변수에 결과값이 담기고, doAsync()는 명령만 내린 뒤 바로 return 값을 반환한다. 이후 doAsync() 함수 수행 명령을 내린 시점에서 someAsyncFunc()와 someAsyncFunc2가 순차적으로 실행된다.&lt;/p&gt;
&lt;p&gt;비동기 처리를 동기적으로 수행하기 위해 여태껏 await에만 초점을 맞추고 있었는데, 이번엔 await를 사용하지 않고 async만 사용해 보았다.&lt;br&gt;async-await는 기본적으로 페어지만, 함수를 비동기로 실행할 때도 있는 법이다.&lt;br&gt;두 키워드를 좀더 제대로 알게 된 것 같아 기쁘다. 유익한 경험이었다.&lt;/p&gt;
</content>
        <category term="비동기" />
        <category term="asyncawait" />
        <category term="postman" />
        <category term="속도 개선" />
        <updated>2022-01-27T00:56:15.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2022/01/21/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%83%88%EB%8B%A8%EC%9E%A5/</id>
        <title>블로그 새단장</title>
        <link rel="alternate" href="https://coding-coconut.com/2022/01/21/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%83%88%EB%8B%A8%EC%9E%A5/"/>
        <content type="html">&lt;p&gt;기존 블로그 레이아웃과 테마를 새로 리뉴얼했다!&lt;br&gt;깔끔해서 마음에 든다.&lt;/p&gt;
&lt;p&gt;이번에 새 테마를 만들면서, 기존 Hexo 공식 문서를 많이 파악해 보는 시간을 가졌다.&lt;br&gt;조만간 레이아웃 만들기도 정리해서 포스팅할 예정.&lt;/p&gt;
</content>
        <category term="잡담" />
        <updated>2022-01-21T07:40:37.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2021/09/17/%EB%A7%81%ED%81%AC-%EC%8A%A4%ED%81%AC%EB%9E%A9-%EB%B0%8F-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C/</id>
        <title>링크 스크랩 및 참고자료</title>
        <link rel="alternate" href="https://coding-coconut.com/2021/09/17/%EB%A7%81%ED%81%AC-%EC%8A%A4%ED%81%AC%EB%9E%A9-%EB%B0%8F-%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C/"/>
        <content type="html">&lt;h3 id=&#34;리눅스-명령어들&#34;&gt;&lt;a href=&#34;#리눅스-명령어들&#34; class=&#34;headerlink&#34; title=&#34;리눅스 명령어들&#34;&gt;&lt;/a&gt;리눅스 명령어들&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sudo grep -ir &amp;#39;bind-address&amp;#39; /etc/mysql/&lt;/code&gt;&lt;br&gt;해당 위치에 원하는 텍스트가 있는 파일을 찾는 명령어&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iptables -I INPUT -s 1.1.1.1 -j DROP&lt;/code&gt;&lt;br&gt;특정 IP막기&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://thisblogbusy.tistory.com/entry/iptables-%ED%8A%B9%EC%A0%95-IP-%EB%A7%89%EA%B8%B0?category=692140&#34;&gt;https://thisblogbusy.tistory.com/entry/iptables-특정-IP-막기?category=692140&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;cat /var/log/apache2/access.log&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tail access.log&lt;/code&gt;&lt;br&gt;접속 기록 확인&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nohup npm start &amp;amp;&lt;/code&gt;&lt;br&gt;노헙으로 종료가되어도 계속 실행되도록 백그라운드로 npm start실행.&lt;/p&gt;
&lt;h3 id=&#34;https-인증&#34;&gt;&lt;a href=&#34;#https-인증&#34; class=&#34;headerlink&#34; title=&#34;https 인증&#34;&gt;&lt;/a&gt;https 인증&lt;/h3&gt;&lt;p&gt;호스트 서버컴퓨터에 snap 깔고 certbot 깔고&lt;/p&gt;
&lt;p&gt;&lt;code&gt;certbot --apache&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;리버스프록시로 아파치를 설정해뒀다면 아파치 사양으로 certbot이 자동으로 인증서를 설정해줌.&lt;/p&gt;
&lt;h3 id=&#34;ip-접속기록-확인-아파치-이용&#34;&gt;&lt;a href=&#34;#ip-접속기록-확인-아파치-이용&#34; class=&#34;headerlink&#34; title=&#34;ip 접속기록 확인 (아파치 이용)&#34;&gt;&lt;/a&gt;ip 접속기록 확인 (아파치 이용)&lt;/h3&gt;&lt;p&gt;&lt;code&gt;sudo awk &amp;#39;&amp;#123; print $1&amp;#125;&amp;#39; /var/log/apache2/access.log | sort | uniq -c | sort -nr | head -n 10&lt;/code&gt;&lt;br&gt;접속기록 빈도 10위까지 출력&lt;/p&gt;
&lt;h3 id=&#34;ssh-키페어-등록하기&#34;&gt;&lt;a href=&#34;#ssh-키페어-등록하기&#34; class=&#34;headerlink&#34; title=&#34;ssh 키페어 등록하기&#34;&gt;&lt;/a&gt;ssh 키페어 등록하기&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://extrememanual.net/26803&#34;&gt;https://extrememanual.net/26803&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;puttygen 이용, rsa 키페어 생성&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;퍼블릭키와 프라이빗키 저장&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;호스트 서버 들어가서 유저계정 고유 폴더에 .ssh 폴더 만들기&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;mkdir .ssh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vi .ssh/authorized_keys&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;해당 편집기에 public key 부분을 텍스트 붙여넣기 후 저장&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;드래그앤드롭-라이브러리&#34;&gt;&lt;a href=&#34;#드래그앤드롭-라이브러리&#34; class=&#34;headerlink&#34; title=&#34;드래그앤드롭 라이브러리&#34;&gt;&lt;/a&gt;드래그앤드롭 라이브러리&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://interactjs.io/&#34;&gt;https://interactjs.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://web.dev/drag-and-drop/&#34;&gt;https://web.dev/drag-and-drop/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;드래그앤드롭 파일 업로드 및 설명 튜토리얼.&lt;/p&gt;
&lt;h3 id=&#34;Electron-시작하기&#34;&gt;&lt;a href=&#34;#Electron-시작하기&#34; class=&#34;headerlink&#34; title=&#34;Electron 시작하기&#34;&gt;&lt;/a&gt;Electron 시작하기&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://musma.github.io/2019/07/17/electron-getting-started.html&#34;&gt;https://musma.github.io/2019/07/17/electron-getting-started.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Electron을 이용해서 node.js 와 js로 데스크톱 어플리케이션을 만들 수 있다.&lt;/p&gt;
</content>
        <category term="스크랩" />
        <updated>2021-09-17T00:30:08.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2021/08/13/Certbot%EC%9C%BC%EB%A1%9C-https-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/</id>
        <title>Certbot으로 https 서브도메인 등록하기</title>
        <link rel="alternate" href="https://coding-coconut.com/2021/08/13/Certbot%EC%9C%BC%EB%A1%9C-https-%EC%84%9C%EB%B8%8C%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%93%B1%EB%A1%9D%ED%95%98%EA%B8%B0/"/>
        <content type="html">&lt;p&gt;시행착오가 좀 많았다.&lt;/p&gt;
&lt;p&gt;회사서 홈페이지를 새로 구축했다. 구축하는 김에 구식이었던 정적 호스팅을 버리고.. 서버도 올릴 수 있도록 요즘 클라우드 호스팅으로 갈아탔다!&lt;/p&gt;
&lt;p&gt;AWS EC2처럼 가상컴퓨터지만.. 클라우드라서 훨씬 가격이 저렴하다.  (사실 써본 입장으로써 AWS는 좀 깡패라는 생각이 든다 가격 측정상…ㅡ,.ㅡ)&lt;/p&gt;
&lt;p&gt;클라우드 중 가장 싸다는 Vultr호스팅을 이용하고 싶었으나.. 회원가입할때 1인 1계정 원칙이 있는데, 하필이면 잘 모르는 초짜 고고넛이 회원가입할 때 실수를 해서 락이 걸렸다. &lt;/p&gt;
&lt;p&gt;문의 처리는 빨랐지만  Vultr가 해외 호스팅 서버라 처리하는게 좀 번거로워서..  고심한 끝에,&lt;/p&gt;
&lt;p&gt;cafe24의 클라우드 호스팅 서비스를 이용하기로 결정했다.&lt;/p&gt;
&lt;p&gt;가격도 Vultr 랑 비교해서 둘이 비슷하다! 성능은 cafe24 클라우드 호스팅 쪽이 램을 더 잘 지원하고.. 용량이 쪼끔 더 작다.(벌쳐는 램이 작고 용량이 큰 편) 그리고.. 벌쳐는 클라우드 서버를 사면 공인 IP도 같이 주는데 cafe24쪽은 공인 IP를 따로 사야한다.&lt;/p&gt;
&lt;p&gt;사내 홈피처럼 공적인 부분은 공인 IP가 꼭 필요하므로~ 공인 IP도 클라우드 서버와 같이 구매했다.&lt;/p&gt;
&lt;p&gt;개인 블로그 구축을 경험삼아 Ubuntu 18 바이오닉 서버에 Node.js Express서버를 배포하려고 했다.&lt;/p&gt;
&lt;p&gt;cafe24클라우드의 특성상 보안을 위해 SSH키를 사용해야만 접속할 수 있고,&lt;/p&gt;
&lt;p&gt;SSH 키는 cafe24클라우드가 서버 살 때 키까지 만들어준다.&lt;/p&gt;
&lt;p&gt;SSH 키로 접속할때 고고낫은 Putty를 이용했으므로, 키를 읽어서 변환해주는 puttygen이 필요했다.&lt;/p&gt;
&lt;p&gt;홈피서 pem 키를 받고 puttygen에서 불러오기를 하면 exe프로그램이 putty전용으로 key를 변환해준다.&lt;/p&gt;
&lt;p&gt;save Private Key를 하면 ppk로 내려지는데,&lt;/p&gt;
&lt;p&gt;Putty &amp;gt; Connection &amp;gt; SSH &amp;gt; Auth 에서 맨 밑 항목을 보면 Private key file for authentication 하고 ppk키를 등록하는 부분이 있다.&lt;/p&gt;
&lt;p&gt;푸티에도 등록해주고, 파일질라에도 상단의 사이트 관리자 항목을 보면 키를 등록해주는 부분이 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;❕  Putty 와 Filezila 연결을 위한 방화벽 설정은 cafe24 클라우드 웹콘솔 화면에서 사람이 정말~ 설정하기 쉽도록 되어 있다. ufw 치고.. 막 콘솔 창 안 들여다봐도 된다 ㅎㅎ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;여튼 key를 이용해서 putty로 ssh접속하면, 지정된 계정 이름으로 접속하게 되어있는데, 이 계정한텐 root권한이 없어서 명령수행 할 때 일시적으로 제약을 해제해줘야 했다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo -i&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;파일질라로 배포할 파일 업로드하는 과정은 생략한다. Express(Node)는 일종의 SSR서버이므로~ 직접 접근하게 하면 좀 위험하고 정적 서버인 apache를 통해 프록시하면 좋을 것 같아서 apache2도 깔았다. 프록시설정하는 과정도 생략한다!&lt;/p&gt;
&lt;p&gt;인터넷 상으로 접속 확인하고 ip도메인 연결하고 도메인 주소를 치면 사이트가 다 뜨는 것까지 확인했다.(다만 http일 뿐이지..)&lt;/p&gt;
&lt;h3 id=&#34;본론&#34;&gt;&lt;a href=&#34;#본론&#34; class=&#34;headerlink&#34; title=&#34;본론!&#34;&gt;&lt;/a&gt;본론!&lt;/h3&gt;&lt;p&gt;서론이 쫌 길었다.. 클라우드 얘기만 대판 ..ㅡ.ㅡ) 이제 https를 등록할 차례인데,&lt;/p&gt;
&lt;p&gt;Certbot이 너무 친절한게.. 공식 사이트 가서 서버 종류랑 컴퓨터 운영체제를 입력하면 어떻게 깔아야 하는지 튜토리얼이 너무 잘 되어있다…ㅠ.ㅠ&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://certbot.eff.org/lets-encrypt/ubuntubionic-apache&#34;&gt;https://certbot.eff.org/lets-encrypt/ubuntubionic-apache&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;아파치 사양으로 하라는 대로 했다. 여기까진 아무 문제 없었다. 근데 왠걸.. 선택지가 두개 뜨는데, 한 도메인은 www를 포함하고, 다른 한 도메인은 www를 포함하지 않는 도메인을 보여주면서 둘 중 인증서 발급 받을 주소를 하나 택하라고 한다&lt;/p&gt;
&lt;p&gt;둘다 발급받을건데.? 하고 서트봇 인증서 발급 명령을 두번 실행하면&lt;/p&gt;
&lt;p&gt;인증서는 두개인데.. 사이트 들어가서 확인해봤더니만,&lt;/p&gt;
&lt;p&gt;정작 적용은 맨 마지막에 발급받은 인증서 하나만 되는 것 같았다.&lt;/p&gt;
&lt;p&gt;여기서 좀 많이 해멨는데, 방법은.. 인증서를 하나만 발급받고 (www든 www가 아니든)&lt;/p&gt;
&lt;p&gt;아래처럼 서브도메인으로 인증서를 확장하는 명령을 내리는 것이었다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;certbot --expand -d existing.com,example.com,newdomain.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;이렇게 하면 하나의 인증서 아래에 여러 서브도메인이 붙는다.&lt;/p&gt;
&lt;p&gt;여튼 이걸로 도메인 여러개 발급받는 것 해결했음…&lt;/p&gt;
</content>
        <category term="certbot" />
        <updated>2021-08-12T23:55:12.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2021/03/08/Hexo%EC%99%80-API%EC%84%9C%EB%B2%84-%EA%B0%84%EC%9D%98-%ED%86%B5%EC%8B%A0/</id>
        <title>Hexo와 API 서버 간의 통신</title>
        <link rel="alternate" href="https://coding-coconut.com/2021/03/08/Hexo%EC%99%80-API%EC%84%9C%EB%B2%84-%EA%B0%84%EC%9D%98-%ED%86%B5%EC%8B%A0/"/>
        <content type="html">&lt;p&gt;Hexo 블로그에 서버 API를 이용하는 덧글 위젯을 직접 만들고 싶다면 참조할 수 있는 포스팅이다.&lt;br&gt;Hexo는 정적 웹 블로그를 빠르게 작성할 수 있도록 하는 데에 주요 목적이 있기 때문에, 쿼리를 통해 데이터를 가져오고 서버통신을 통해 html dom을 렌더링하는 로직에 대한 지원은 그다지 좋지 않다.&lt;br&gt; Hexo 공식 사이트에서 지원하는 플러그인, 또는 Disqus나 Utterances 와 같은 덧글 위젯이 있지만.. 이런 위젯은 커스터마이징이나 데이터 저장 방식이 유연하지 못하다는 게 사실이다.&lt;/p&gt;
&lt;p&gt;요약해서 말하자면, 결국 개발자들의 입맞에 맞지 않기 때문에 커스텀 위젯을 만들고자 하는 것이다 ^^;;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;뭘 만들 것인가?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hexo처럼 정적 프레임워크와 같이 사용할 수 있는, 덧글 위젯을 만들려고 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;어떻게 만들 것인가?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hexo와 호환되려면 어떻게 해야 할까?&lt;br&gt;Hexo는 정적 블로그형 웹페이지 제작에 최적화된 별도의 서버를 가지고 있다. 이 서버는 Hexo를 가동시킬 때 .md(마크다운) 파일을 html로 내려준다.&lt;/p&gt;
&lt;p&gt;*문제점 : Hexo와 위젯 API서버가 다르기 때문에 크로스오리진 이슈가 발생한다.&lt;/p&gt;
&lt;p&gt;:할 수 있는 방법&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;위젯 따로 구동되는 방식을 이용해야 한다. 다른 웹페이지를 볼 수 있는 iframe 태그를 이용할수도 있고, 데이터만 전송받아 Hexo 상에서 DOM을 따로 그릴 수도 있다. 데이터 교환 방식은 ajax 또는 axios를 이용할 것이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;흐름 구상은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hexo에서 ajax 혹은 axios를 이용하여 데이터를 요청한다.&lt;/li&gt;
&lt;li&gt;api를 통해 댓글 데이터를 전송한다.&lt;/li&gt;
&lt;li&gt;전송된 데이터를 받아서 Hexo상에서 HTML DOM을 직접 그린다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;..해서 다음과 같은 과정이 될 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hexo ajax 요청 =&amp;gt; 위젯 API의 수신 및 응답 =&amp;gt; Hexo ajax 응답 완료 =&amp;gt; Hexo의 js로 DOM 렌더링&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;그렇다면 이제 뭘 이용해서 구현할까?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;페이지를 렌더링해서 iframe하는 방식도 해봤고 데이터만 받아와서 hexo상에서 렌더링하는 방식도 해봤는데&lt;br&gt;iframe은 크로스오리진 이슈 때문에 iframe 내부의 DOM을 조작하기가 까다로워서 ajax 요청을 통해 api 서버로부터 데이터를 받아와서&lt;br&gt;Hexo 측에서 댓글 위젯을 그리는 편을 택했다.&lt;/p&gt;
&lt;h3 id=&#34;1-Node-js-Express-프레임워크로-위젯이-가동될-서버-만들기&#34;&gt;&lt;a href=&#34;#1-Node-js-Express-프레임워크로-위젯이-가동될-서버-만들기&#34; class=&#34;headerlink&#34; title=&#34;1. Node.js Express 프레임워크로 위젯이 가동될 서버 만들기&#34;&gt;&lt;/a&gt;1. Node.js Express 프레임워크로 위젯이 가동될 서버 만들기&lt;/h3&gt;&lt;!-- 이미지 --&gt;
&lt;p&gt;express를 사용하여 api 서버의 틀을 잡는다.&lt;/p&gt;
&lt;!-- 이미지 --&gt;
&lt;p&gt;댓글이 저장될 데이터베이스 또한 작성해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;2-위젯-서버의-API-로직-작성하기&#34;&gt;&lt;a href=&#34;#2-위젯-서버의-API-로직-작성하기&#34; class=&#34;headerlink&#34; title=&#34;2. 위젯 서버의 API 로직 작성하기&#34;&gt;&lt;/a&gt;2. 위젯 서버의 API 로직 작성하기&lt;/h3&gt;&lt;!-- 이미지 --&gt;
&lt;p&gt;Node Express 서버에 기본 CRUD를 할 수 있도록 기능을 만든다.&lt;/p&gt;
&lt;h3 id=&#34;3-Hexo-ajax-요청-로직-작성&#34;&gt;&lt;a href=&#34;#3-Hexo-ajax-요청-로직-작성&#34; class=&#34;headerlink&#34; title=&#34;3. Hexo ajax 요청 로직 작성&#34;&gt;&lt;/a&gt;3. Hexo ajax 요청 로직 작성&lt;/h3&gt;&lt;!-- 이미지 --&gt;
&lt;p&gt;Hexo 댓글 위젯의 버튼을 누르면 ajax 또는 axios 를 통해 위에서 작성한 api에 데이터를 요청할 수 있도록 한다.&lt;/p&gt;
&lt;h3 id=&#34;4-댓글-DOM-렌더링-로직-작성&#34;&gt;&lt;a href=&#34;#4-댓글-DOM-렌더링-로직-작성&#34; class=&#34;headerlink&#34; title=&#34;4. 댓글 DOM 렌더링 로직 작성&#34;&gt;&lt;/a&gt;4. 댓글 DOM 렌더링 로직 작성&lt;/h3&gt;&lt;!-- 이미지 --&gt;
&lt;p&gt;데이터 전송이 끝나면 추가되는 댓글 또는 삭제되는 댓글을 렌더링할 수 있도록 html DOM 렌더러를 작성한다.&lt;/p&gt;
&lt;h3 id=&#34;5-댓글이-갱신되는것을-확인&#34;&gt;&lt;a href=&#34;#5-댓글이-갱신되는것을-확인&#34; class=&#34;headerlink&#34; title=&#34;5. 댓글이 갱신되는것을 확인&#34;&gt;&lt;/a&gt;5. 댓글이 갱신되는것을 확인&lt;/h3&gt;&lt;!-- 이미지 --&gt;
&lt;p&gt;댓글이 잘 작성된 것을 확인할 수 있었다.&lt;br&gt;지금은 익명 댓글이지만, 로그인 위젯을 만들어 놓으면 api 서버로부터 세션검증을 통해 유저검증을 하는 것도 가능할 것 같다.&lt;/p&gt;
</content>
        <category term="hexo" />
        <updated>2021-03-08T07:46:45.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2021/02/09/Hexo-%ED%85%8C%EB%A7%88-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%81%EC%9A%A9%EA%B8%B0/</id>
        <title>Hexo 테마 블로그 적용기</title>
        <link rel="alternate" href="https://coding-coconut.com/2021/02/09/Hexo-%ED%85%8C%EB%A7%88-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%81%EC%9A%A9%EA%B8%B0/"/>
        <content type="html">&lt;p&gt;블로그의 첫 게시물은 도커가 장식했지만, 그래도 명색이 헥소로 기껏 만든 블로그인데 적용기를 써보자~&lt;br&gt;다른 블로그를 봐도 헥소 테마 레이아웃을 만드는 방법은 잘 나와있지 않아서, 이왕 하는 김에 테마 만드는 법도 같이 기술하련다.&lt;br&gt;헥소 프레임워크를 좀 만져봤는데, 작동원리는 쪼끔 알겠고 헥소 기반 테마 만드는법을 모르는 사람에게 추천한다. 헥소 공식 사이트에도 만드는 방법이 어렴풋하게나마 나와있으니 참조해도 좋다(그리 자세히 나와있진 않지만..)&lt;/p&gt;
&lt;h3 id=&#34;1-레이아웃-폴더-만들기&#34;&gt;&lt;a href=&#34;#1-레이아웃-폴더-만들기&#34; class=&#34;headerlink&#34; title=&#34;1. 레이아웃 폴더 만들기&#34;&gt;&lt;/a&gt;1. 레이아웃 폴더 만들기&lt;/h3&gt;&lt;p&gt;우선… 블로그 폴더 구조는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/postimg/blog_structure.png&#34; alt=&#34;blog_structure&#34;&gt;&lt;/p&gt;
&lt;p&gt;먼저  프로젝트 루트 폴더에 themes 폴더를 만들고, 내부에 자기가 만들 테마의 이름을 짓자.&lt;br&gt;이 안에 블로그 틀이 들어갈 📁layout 폴더와 img/js/font처럼 정적 소스들이 들어갈 📁source 폴더를 만든다.&lt;br&gt;블로그 테마에 적용시킬 변수들을 모아 관리하는 &lt;code&gt;_config.yml&lt;/code&gt;파일도 만든다.&lt;/p&gt;
&lt;h3 id=&#34;3-렌더링할-템플릿-엔진-선택&#34;&gt;&lt;a href=&#34;#3-렌더링할-템플릿-엔진-선택&#34; class=&#34;headerlink&#34; title=&#34;3. 렌더링할 템플릿 엔진 선택&#34;&gt;&lt;/a&gt;3. 렌더링할 템플릿 엔진 선택&lt;/h3&gt;&lt;p&gt;필자는 Express를 사용해와서.. 상대적으로 익숙한 ejs로 작성할 것이다.&lt;br&gt;블로그의 전체 레이아웃을 담당하는 &lt;code&gt;layout.ejs&lt;/code&gt; 파일을 📁layout 폴더 안에 만들어준다.&lt;br&gt;이 &lt;code&gt;layout.ejs&lt;/code&gt; 파일이 블로그의 뼈대 역할을 해줄 것이다.&lt;/p&gt;
&lt;h3 id=&#34;4-부분-렌더링-파츠별로-작성&#34;&gt;&lt;a href=&#34;#4-부분-렌더링-파츠별로-작성&#34; class=&#34;headerlink&#34; title=&#34;4. 부분 렌더링 파츠별로 작성&#34;&gt;&lt;/a&gt;4. 부분 렌더링 파츠별로 작성&lt;/h3&gt;&lt;p&gt;📁layout 폴더 안에 각 부분별 파츠가 들어갈📁_partial 폴더를 만들어주고, &lt;code&gt;layout.ejs&lt;/code&gt; 파일을 한번 보자.&lt;/p&gt;
&lt;h3 id=&#34;5-레이아웃-변수를-담당할-config-yml-파일-작성&#34;&gt;&lt;a href=&#34;#5-레이아웃-변수를-담당할-config-yml-파일-작성&#34; class=&#34;headerlink&#34; title=&#34;5. 레이아웃 변수를 담당할 _config.yml 파일 작성&#34;&gt;&lt;/a&gt;5. 레이아웃 변수를 담당할 _config.yml 파일 작성&lt;/h3&gt;&lt;p&gt;ejs 문법 속에 동적으로 들어갈 변수들을 yml 로 작성한다.&lt;/p&gt;
&lt;h3 id=&#34;6-부가적인-것&#34;&gt;&lt;a href=&#34;#6-부가적인-것&#34; class=&#34;headerlink&#34; title=&#34;6. 부가적인 것&#34;&gt;&lt;/a&gt;6. 부가적인 것&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;서버 통신이 필요한 무언가를 만들고 싶다.. 가령 댓글이라거나..&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hexo가 직접 댓글서비스를 지원하진 않지만, 관련 플러그인을 지원한다.&lt;br&gt;댓글을 붙이고 싶다면, 상세한 커스터마이징 없이 &lt;a href=&#34;https://utteranc.es/&#34;&gt;Utterances&lt;/a&gt;나 &lt;a href=&#34;https://help.disqus.com/en/&#34;&gt;Disqus&lt;/a&gt;처럼 댓글 위젯을 서비스받는 방법도 있다. Hexo 에서 직접 추천하는 방법이며, 공식 메뉴얼도 있다!&lt;/p&gt;
&lt;p&gt;직접 만들고 싶다면, 아쉽게도 Hexo는 정적 서비스를 중점적으로 빠르게 작성하기 위한 프레임워크이기 때문에, 서버통신이 필요한 무언가를 작성할 때 그렇게 용이하지는 않다. 이렇게 되면.. 정적 소스 폴더 안의 js로 직접 서버 API로 ajax를 날리는 방법을 택해야💦..&lt;/p&gt;
&lt;p&gt;이럴 바에야 차라리 서버사이드 렌더링(SSR) 방식으로 만드는 게 더 낫지 않은가 고민해보길 바란다. &lt;/p&gt;
&lt;p&gt;그래도 Hexo 블로그에 서버 API를 이용하는 덧글 위젯을 직접 만들고 싶다면… &lt;a href=&#34;#&#34;&gt;[링크]:Hexo 와 API 서버 간의 통신&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;iframe 으로 위젯 만들기?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;iframe 내부에 들어갈 위젯이 고정 높이폭과 너비를 가진다면 가능하다!&lt;br&gt;혹은 position: absolute; 로 동동 떠 있으면 iframe으로 위젯을 만들어도 좋다.&lt;/p&gt;
</content>
        <category term="hexo" />
        <updated>2021-02-09T03:19:02.000Z</updated>
    </entry>
    <entry>
        <id>https://coding-coconut.com/2021/02/05/Docker-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A0%95%EB%A6%AC/</id>
        <title>Docker 명령어 정리</title>
        <link rel="alternate" href="https://coding-coconut.com/2021/02/05/Docker-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A0%95%EB%A6%AC/"/>
        <content type="html">&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Docker_%28container_engine%29_logo.svg/1200px-Docker_%28container_engine%29_logo.svg.png&#34; alt=&#34;titleimg&#34;&gt;&lt;/p&gt;
&lt;p&gt;도커를 한번 써 보니 생각보다 서버를 운영하는 데 편리하고 컨테이너 단위 관리가 용이해서, 이를 잊어버리는 일이 없도록 실행부터 가동 중지까지, 방법을 정리하려고 한다.&lt;/p&gt;
&lt;h3 id=&#34;1-서버-이미지-만들기&#34;&gt;&lt;a href=&#34;#1-서버-이미지-만들기&#34; class=&#34;headerlink&#34; title=&#34;1. 서버 이미지 만들기&#34;&gt;&lt;/a&gt;1. 서버 이미지 만들기&lt;/h3&gt;&lt;p&gt;서버 구축 후, 프로젝트 폴더를 Shift + 우클릭하여 cmd(명령 프롬프트 창) 실행&lt;/p&gt;
&lt;p&gt;Docker Desktop 이 설치되어있고, 가동시켜서 현재 서비스가 돌아가고 있다는 전제 하에 아래의 명령어를 입력&lt;/p&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;docker build -t [생성할 이미지명] .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;생성할 이미지명 예시 : ex) MyContainer&lt;/p&gt;
&lt;p&gt;온점까지 제대로 입력해야한다.&lt;br&gt;해당 명령어를 실행하면, 도커가 프로젝트의 Dockerfile 이 제대로 작성되었다는 가정하에 Dockerfile 내부의 명령어를 실행시켜 컨테이너를 구축한다. 실행 예시는 다음 링크를 참조 &lt;a href=&#34;https://hexo.io&#34;&gt;[링크]:도커파일 작성하기(Node.js Express)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-이미지-실행하기&#34;&gt;&lt;a href=&#34;#2-이미지-실행하기&#34; class=&#34;headerlink&#34; title=&#34;2. 이미지 실행하기&#34;&gt;&lt;/a&gt;2. 이미지 실행하기&lt;/h3&gt;&lt;p&gt;이미지를 빌드해서 생성했으면, 이제 컨테이너화하여 서버를 운영할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Docker Desktop 가동&lt;/li&gt;
&lt;li&gt;좌측의 Images 에 지정했던 이미지명 찾기&lt;/li&gt;
&lt;li&gt;RUN 을 통해 가동 (세부설정은 Optional Settings를 통해 설정할 수 있다. 컨테이너명과 Port 등을 지정할 수 있다.)&lt;/li&gt;
&lt;li&gt;성공적으로 가동하면 왼측 Containers/Apps 의 컨테이너 목록란에 초록색 컨테이너 박스로 표기된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;+) 만약 Dockerfile 등의 결함이 있거나 하면 shell 실행이 중지되는데,&lt;br&gt;&lt;img src=&#34;/img/postimg/container_disable.png&#34; alt=&#34;containericon&#34;&gt;&lt;br&gt;요로코롬 컨테이너 아이콘이 회색으로 표기된다.&lt;br&gt;클릭을 통해 해당 로그란을 확인할 수 있다.&lt;br&gt;이 경우에는 파일 빌드 자체에 오류가 있는 경우이므로 이미지를 재빌드해야만 한다.&lt;/p&gt;
&lt;h3 id=&#34;3-컨테이너-실행-확인&#34;&gt;&lt;a href=&#34;#3-컨테이너-실행-확인&#34; class=&#34;headerlink&#34; title=&#34;3. 컨테이너 실행 확인&#34;&gt;&lt;/a&gt;3. 컨테이너 실행 확인&lt;/h3&gt;&lt;p&gt;도커 위에서 돌아가고 있는 이미지 컨테이너를 확인해 보자.&lt;br&gt;&lt;img src=&#34;/img/postimg/container_correct.png&#34; alt=&#34;containericon&#34;&gt;&lt;br&gt;정상적으로 돌아가고 있다면 컨테이너 박스가 녹색으로 표기된다.&lt;br&gt;필자는 웹서버이므로 웹 연결을 통해 컨테이너가 해당 로컬 포트를 통해 돌아가고 있는 것을 확인하였다.&lt;br&gt;이미지 가동 시 포트를 따로 뚫어 뒀다면 포트포워딩을 통해 포팅하고있는 컴퓨터의 외부 접속도 가능하다.&lt;/p&gt;
&lt;h3 id=&#34;4-컨테이너-중지&#34;&gt;&lt;a href=&#34;#4-컨테이너-중지&#34; class=&#34;headerlink&#34; title=&#34;4. 컨테이너 중지&#34;&gt;&lt;/a&gt;4. 컨테이너 중지&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;/img/postimg/active_server_delete.png&#34; alt=&#34;containericon&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;위 그림처럼 Docker Desktop의 Container/Apps 목록에서 컨테이너를 Delete 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;서버에 대한 이미지는 기존에 작성해 놓았기 때문에 컨테이너를 삭제해도 무방하다!&lt;br&gt;재가동시킬 땐 이미지를 다시 가동시키면 되니깐..&lt;/p&gt;
&lt;h3 id=&#34;5-그-외-명령어들&#34;&gt;&lt;a href=&#34;#5-그-외-명령어들&#34; class=&#34;headerlink&#34; title=&#34;5. 그 외 명령어들&#34;&gt;&lt;/a&gt;5. 그 외 명령어들&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;파일 접근하기 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;+) 서버가 돌아갈때 로그 등을 생성하도록 해두었다면, 현재 돌아가고 있는 컨테이너의 내부 파일에 접근하는 것도 가능하다.&lt;/p&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;docker cp [컨테이너명]:[접근할 파일 경로] [저장할 경로명]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;컨테이너명 예시 : ex) MyConatiner&lt;br&gt;접근할 파일 경로 예시 : ex)/root/etc/logs&lt;br&gt;파일을 저장할 경로명 예시: ex) C:\Users\Desktop\Server_Container_Logs&lt;/p&gt;
&lt;p&gt;위 커맨드를 실행하면 서버 내부의 로그파일을 빼낼 수 있다!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;컨테이너 내부 시간대 맞추기&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;+) 이미지 가동 시 옵셔널 세팅에 포함되지 않은 기능이다.. ㅡ.ㅡ 왜 이렇게 해놓았을까..?&lt;br&gt; 다소 곤란한 감이 있지만 이 경우도 명령어로 제어가 가능하다.&lt;br&gt; 컨테이너 가동 시에 시간대를 국제시간대로 맞춰주면 된다.&lt;/p&gt;
&lt;figure class=&#34;highlight plain&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;docker run --name [컨테이너명] -p [로컬로 접근할 포트명]:[컨테이너 내부로 뜷어놓을 포트명]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;-e TZ&amp;#x3D;Asia&amp;#x2F;Seoul [이미지명]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt; 이런 식으로 가동하면 -e 커맨드를 통해 이미지 컨테이너의 시간대가 서울로 설정되어 가동된다.&lt;/p&gt;
</content>
        <category term="docker" />
        <category term="hexo" />
        <updated>2021-02-05T00:00:04.000Z</updated>
    </entry>
</feed>

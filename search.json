[{"title":"Ubuntu 20.10 이하 버전에서 podman 설치하기","url":"/post/clgyf00n8000u685ogeyncd1f/","content":"# ubuntu 20.10 이하 버전에서 podman 설치하기\n\nAWS EC2 <code>Ubuntu 20.04 LTS</code> 에 설치하였다.\n\n### 1. 쿠빅 리포지토리 추가\n``` bash \nsudo sh -c \"echo 'deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/ /' > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list\"\n```\n> 입력하고 커맨드해도 아무것도 출력되지 않는데 정상적으로 추가된 것이다.\n\n### 2. 리포지토리 키 추가\n``` bash\nwget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/xUbuntu_20.04/Release.key -O- | sudo apt-key add -\n```\n\n> OK 가 뜨면 성공\n\n### 3. 쿠빅 리포 추가 후 apt 업데이트\n```bash\nsudo apt update\n```\n\n### 4. 포드맨 설치\n```bash\nsudo apt -y install podman\n```\n\n4번 과정까지 마치고 나면 커맨드에서 podman 을 인식할 수 있게 된다.","tags":["ubuntu","podman"],"categories":["AWS","EC2"]},{"title":"EC2에 도메인 바인딩하기","url":"/post/clgyf00n30003685o4sig54cs/","content":"\n## 도메인-로드밸런서-대상그룹-보안규칙-EC2 설정하기\n> 도메인 접근 -> 내부 포트 접근\n80|443 -> 8102\n* 접근 가능 VPC 일치에 주의\n1. EC2인스턴스에 보안그룹 추가하여 포트번호 뜷기 (예: 8102)\n2. 대상그룹의 포트를 EC2인스턴스의 포트번호와 일치시키기 인스턴스:8102 대상그룹:8102(HTTP)\n3. 생성한 대상그룹에 대상 등록으로 EC2인스턴스 바인딩\n4. 대상그룹에 등록된 EC2인스턴스의 헬스체크를 기다리기\n5. 로드밸런서 생성하기\n6. 가용 영역 선택, 생성과정 중 만들어놓은 대상그룹 바인딩시키기\n7. 보안그룹은 웹 전용으로 하기(80,443을 뜷는 보안그룹)\n8. 리스너에서 HTTPS 443 추가, 인증서 선택하기\n9. 기존에 묶인 80리스너를 443리디렉션에 301 응답으로 바꾸기","tags":["aws","배포"],"categories":["AWS"]},{"title":"굶지마 캐릭터 모드 만드는 과정 정리","url":"/post/clgyf00n9000w685o4fdudfqu/","content":"# 굶지마 캐릭터 모드 만드는 과정 정리\n\n> <a href=\"https://forums.kleientertainment.com/forums/topic/28021-getting-started-guides-tutorials-and-examples/\">참조 : 클레이 포럼 모딩 종합 튜토리얼</a>\n\n### 1.캐릭터 샘플 다운받기\n굶지마 캐릭터 빌드 템플릿을 다운받아 준다.\n> Deowolf의 extended character template 다운로드 받기\n * <a href=\"https://github.com/DragonWolfLeo/extendedsamplecharacter-dontstarvetogether\">깃허브</a>\n * <a href=\"https://forums.kleientertainment.com/files/file/950-extended-sample-character/\">굶지마 포럼</a>\n\n둘 다 동일한 파일이니 버전만 잘 확인하면 된다. 굶지마 포럼의 경우 다운받는데 클레이 로그인이 필요할 수 있다.\n\n포럼에는 튜토리얼 영상도 있으니 참조.\n\n<br/>\n\n### 2.vsCode 또는 Notepad++로 이름 바꾸기(대소문자 구분)\n * <a href=\"https://code.visualstudio.com/\">vsCode</a>\n * <a href=\"https://notepad-plus-plus.org/downloads/\">Notepad++</a>\n\n1. 다운받은 프로젝트 파일의 폴더명으로 압축을 푼다.\n\n2. vsCode 또는 Notepad++ 처럼 전체파일 내부의 텍스트 바꾸기와 같은 특수한 기능이 있는 코드 편집기로 프로젝트 폴더를 연다.\n\n![프로젝트 열기](/img/postimg2/project_open.png)\n\n3. 대소문자 구분에 유의하여 캐릭터의 이름을 수정해준다. ( ctrl + f 키를 누르면 탐색 창이 열린다. )\n\n*샘플 캐릭터의 이름은 esctemplate로, <b>반드시 대소문자를 구분</b>하여 바꾸려는 캐릭터의 이름으로 바꿔준다.\n\n![이름 바꾸기(소문자)](/img/postimg2/save_as_project_othername.png)\n![이름 바꾸기(대문자)](/img/postimg2/save_as_project_othername2.png)\n\n> esctemplate, ESCTEMPLATE => 바꾸려는 캐릭터 소문자명, 바꾸려는 캐릭터 대문자명\n\n.lua 내부 파일들은 물론이고, exported안에 있는 프리팹 폴더명과 .scml파일, .png파일의 이름들도 수정해주어야한다.\n\n.xml 파일은 지우게 되니 신경쓰지 않아도 상관없다.\n\n![이름 바꾸기(대문자)](/img/postimg2/save_as_project_othername3.png)\n\n\n👉 클레이 포럼 외부 링크: <a href=\"https://forums.kleientertainment.com/forums/topic/73055-font-what-is-the-font-for-together/?do=findComment&comment=855020\">캐릭터 초상화의 이름을 수정할 수 있는 굶지마 폰트(이미지)</a>\n\n<br/>\n\n### 3.exported, images 의 png 파일 편집하기\n프로젝트 폴더의 exported와 images 폴더 안에 있는 png들을 모드캐릭터에 맞게 이미지를 수정해준다.\n\n*png파일의 픽셀 크기 및 해상도는 건드리지 않는 것이 모드 템플릿에 권고되어있다.\n\n굶지마 애니메이션 빌드 파일을 만들기가 까다롭기 때문이다..\n\n> png이미지를 바꾼 건 좋은데, 바꾼 이미지가 비뚤어지지 않았는지 어떻게 확인할까?\n\n![굶지마 모드 툴](/img/postimg2/mod_tools2.png)\n\n스팀을 켜고, 라이브러리에 들어가서 검색 탭 바로 위쪽에 있는 필터링 바를 클릭해준다.\n\n![굶지마 모드 툴](/img/postimg2/mod_tools.png)\n\nDon't starve mod tools 프로그램이 보일텐데, 미설치인 경우 설치해주자.\n\n![굶지마 모드 툴](/img/postimg2/mod_tools3.png)\n\nMod tools를 우클릭하여 실행하면, 위와 같은 창이 뜬다.\n\nLaunch Spriter를 체크하고 실행한다.\n\n![굶지마 모드 툴](/img/postimg2/show_spriter0.png)\n\nFile > Open Project 로 캐릭터 exported 폴더에 있는 .scml 파일을 다음처럼 열어볼 수 있다.\n\n![굶지마 모드 툴](/img/postimg2/show_spriter.png)\n\n.scml은 게임을 켜지 않고도 캐릭터의 모습을 미리 볼 수 있게 해준다.\n> *주의: png 파일만 편집. scml은 새로 저장하거나 건드리지 않기.\n\n\n모습이 잘 적용된 것 같다면 <b>.scml을 저장하지 말고</b> 4번으로 넘어가자.\n\n<br/>\n\n### 4 anim폴더 내부, .xml, .tex 파일 지우고 로컬 mods 폴더 안에 복사, 붙여넣기\n굶지마는 압축된 .xml과 .tex 파일로 이미지를 불러온다.\n\n컴퓨터가 읽을 수 있는 파일로 변환시키기 위해 프로젝트 폴더 내부의 \nmodicon(모드 아이콘)의 tex,xml. portraits(초상화)의 tex, xml. images 폴더 안에 있는 .tex와 .xml 파일들을 모두 제거해준다.\n또한 컴파일러가 애니메이션 빌드를 다시 생성해야 하기 때문에, 캐릭터 모드 폴더 안에 있는 anim폴더 내부의 zip도 없애준다.\n\n> anim폴더 내부의 zip이 없어야 컴파일러가 .scml을 다시 변환하고, xml파일이 없어야 tex파일과 xml파일을 생성한다.\n\n![필요 없는 파일을 제거한 모습](/img/postimg2/remove_anim_tex_xml_etc.png)\n\nanim 폴더 안의 .zip파일들과 .tex와 .xml을 다 제거해주었다면, 다음 경로로 가서 폴더를 열어준다.\n```\n#굶지마 투게더 모드폴더 경로\nC:\\Program Files (x86)\\Steam\\steamapps\\common\\Don't Starve Together\\mods\n```\n![굶지마 모드 폴더](/img/postimg2/mods_folder.png)\n\n로컬 모드를 적용시키기 위해\nmods 폴더에다 여태껏 만든 프로젝트 폴더를 <b>드래그하지 말고</b>, 원본을 ctrl+c , ctrl+v 한다.\n\n굳이 드래그해서 옮기지 않는 이유는 원본을 보존하기 위함이다.\n\n![굶지마 모드 폴더](/img/postimg2/mods_folder2.png)\n\n<br/>\n\n### 5.Don't starve 게임을 켜서 컴파일러 작동시키기\nDon't starve mod tools 를 다운받은 이후 게임을 켜면,\n까만 콘솔창이 뜨게 되는데 이는 컴파일러이다.\n\n컴파일러가 미변환 모드를 체크하고 .scml => .anim 또는 .zip으로, .png는 tex와 xml로 변환한다.\n\n![굶지마 모드 폴더](/img/postimg2/mods_compiler.png)\n\n컴파일러가 저절로 꺼질 때까지 기다리면, 컴파일러가 변환을 완료하고 굶지마 게임이 자동으로 실행된다.\n\n![인게임 확인](/img/postimg2/test_world_in_mod.png)\n\n게임이 켜진 김에 모드를 적용하고 월드를 생성해 본다.\n\n![인게임 확인](/img/postimg2/test_world_in_mod2.png)\n\n여기까지 잘 따라왔다면 캐릭터의 초상화도 잘 나올 텐데, 정작 캐릭터의 이름이 보이질 않는다.\n\n<br/>\n\n### 6.tex 파일 생성 확인\nsteam의 mods 폴더를 열고 만든 모드 폴더에 들어가보자.\n\nmodicon을 제외하고 각 .png마다 tex와 xml 파일이 생성된 것을 확인할 수 있을 것이다.\n\n![tex와 xml생성 확인](/img/postimg2/tex_and_xml.png)\n\n<br/>\n\n### 7.캐릭터 이름 지정 xml 내부의 tex파일 지정 구문 수정하기\n파일도 정상적으로 생성되었는데, 왜 캐릭터의 이름이 보이지 않는 것일까?\n\n템플릿 파일을 주의깊게 봤다면 이름 png 옆에 조그맣게 안내문 txt 파일이 있는 것을 확인할 수 있다.\n\n내용을 읽어보면, xml 파일을 열어 tex이름을 지정하는 구문을 수정해주어야 이름 텍스트가 적용된다는 말이다.\n\nmods 폴더를 열고 만든 모드 폴더를 코드 에디터로 열어준다.\n\n![names와 names_gold 파일 수정](/img/postimg2/edit_name.png)\n\nnames와 names_gold.xml파일을 열고, 다음처럼 수정하고 저장한다.\n\n![names와 names_gold 파일 수정](/img/postimg2/edit_name2.png)\n\n그리고 자동으로 tex와 xml을 생성하지 않는 modicon.png도 잠깐 images 폴더에 복사해 준다.\n\n컴파일러를 다시 실행시키면, modicon의 tex와 xml이 생성되는 걸 볼 수 있다.\n![모드아이콘 변환](/img/postimg2/modicon_convert.png)\n변환된 모드아이콘은 tex, xml과 같이 modmain.lua가 있는 위치에 넣어주자.\n<br/>\n\n### 8. 작동 확인\n\n![초상화 이름텍스트 확인](/img/postimg2/test_world_in_mod3.png)\n\n초상화와 이름도 잘 출력된다.\n\n인게임에서 테스트하며 모드가 잘 작동되는지 확인한다.\n\n![모드 동작 확인하기1](/img/postimg2/mod_example1.png)\n![모드 동작 확인하기2](/img/postimg2/mod_example2.png)\n\n<br/>\n\n## 그 외\n\n### 심화\n#### 손으로 들 수 있는 간단한 물건 만들기\n> <a href=\"https://forums.kleientertainment.com/forums/topic/29427-tutorial-creating-a-handslot-equippable-item-from-scratch/\">클레이 포럼 링크 참조</a>\n\n<br/>\n\n#### 캐릭터 자체음성 만들기\n> <a href=\"https://forums.kleientertainment.com/forums/topic/27803-tutorial-adding-custom-sound-to-your-custom-character/\">클레이 포럼 링크 참조</a>\n\n<br/>\n\n#### 모드 업로드하는 법\n> 추후 게시 예정..\n\n<br/>\n<br/>\n\n### 간단한 디버깅\n#### 로컬에서 모드 적용하기\n만들어둔 모드 프로젝트 폴더를 mods 아래에 두고 게임을 실행한다.\n프로젝트 폴더의 바로 아래에는 modmain.lua와 modicon.png 또는 tex가 있어야 한다.\n\n<br/>\n\n#### 모드 작동 시 어디서 오류가 나는지 보기\n기존 게임에서는 모드 오류 시 오류 메세지를 반환하고 그대로 게임이 멈추었으나, 모더가 아닌 일반 사용자들의 이용을 고려한 탓인지 오류 메세지를 master로그에 숨기고, \n사용자들이 모드를 배제하고 게임을 플레이할 수 있도록 업데이트되었다.\n덕분에 모드 디버깅이 좀 까다로워졌다.\n```\n#투게더 로그파일 경로\nC:\\Users\\user\\Documents\\Klei\\DoNotStarveTogether\\master_server_log\n```\n>해당 파일에서 LUA ERROR 구문을 찾으면 된다. 무슨 오류이며 몇번째 줄에서 오류가 났는지 상세하다.\n\n모드 파일에 문제가 없다면 대부분 resolve path, 경로를 찾지 못하는 오류이다.\nasset등에서 참조하는 경로에 오탈자가 있거나, 어느 한 구문을 빼먹었거나,\ntex파일이 생성되지 않아서 파일을 찾을 수 없는 경우, 파일 누락 등이 원인이다.\n\n<br/>\n\n#### 아이템 소환하기\n모드로 만들어둔 아이템을 바로 테스트해보고싶을 수 있다.\n아이템을 prefab으로 등록해두었다면 /c_give(\"아이템 프리팹명\",갯수) 로 캐릭터 인벤토리에 들어오게 할 수 있다.\n\n``` cmd\n#아이템 인벤토리에 넣기\nc_give(\"cutgrass\",5)\n```\n\n```\n#아이템 소환하기\nc_spawn(\"twigs\",3)\n```\n\n> <a href=\"https://dontstarve.fandom.com/wiki/Console/Don%27t_Starve_Together_Commands\">참조링크: 굶지마 콘솔 커맨드 모음</a>\n\n<br/>\n\n## 해결되지 않은 이슈\n#### Together: saveslot 초상화에 대한 이슈\n- 서버 리스트를 뿌려주는 화면에서 모드를 불러오지 못하기 때문에, 세이브파일 캐릭터 초상화에 항상 종이 윌슨이 그려지는 이슈. 포럼에서도 해결하기 까다로운 문제인 듯.\n\n#### .dyn 파일에 관한 것\n- 워톡스 등 클레이가 유료로 판매하는 아이템 또는 캐릭터의 애니메이션이 들어있는 파일이다. 이는 상업적 이용과도 연관되어 있다. 공식에서도 뜯지 말라고 하고, 무엇보다 암호화되어있다.","tags":["dontstarve","modding"],"categories":["기타","취미&모딩"]},{"title":"Hexo tag 영문태그 대소문자 수정 시 반영되지 않는 오류","url":"/post/clgyf00n50008685ohw7u38oi/","content":"\n태그 영문 대소문자를 수정했을 때 링크 오류가 발생했다\n\n원인은 github에서 영문대소문자 수정 시 커밋사항에 반영되지 않기 때문이다.\n태그를 아예 다른 문자로 수정하고 hexo deploy 로 재배포하면 된다.\n\n참조 링크\nhttps://github.com/hexojs/hexo/issues/2600\n\n","tags":["hexo","error"],"categories":["Hexo"]},{"title":"Linux 서버에서 https 인증과 Apache2 프록시패스 설정하기","url":"/post/clgyf00n8000o685oa5yvbh37/","content":"\n### 들어가며\n인증서 발급방법은 기존에 알고있어서 문제가 되지 않았는데 아파치 설정파일 만지는 법을 까먹어서 한동안 설정파일과 씨름했다.. -.-;;\n로그인한 유저가 관리자 권한일 경우 굳이 sudo를 입력하지 않아도 된다!\n\n### 0. apache2 를 깔려면 apt를 사용해야 하므로 업데이트가 필요\n```bash\nsudo apt update\n```\n\n### 1. linux 전용 apache2 설치\n``` bash\nsudo apt install apache2\n```\n\n### 2. 000-default.conf 편집\n위치는 리눅스 우분투 서버18 기준 맨~ 위 디렉토리 /etc/apache2/site-available/000-default.conf 이다\nvi 로 편집하거나 (apache2 를 처음 설치하게 되면 기본으로 파일설정 권한이 읽기전용이다 -.-;;;)\n\n>파일 권한 수정(읽기 쓰기 실행 다 허용)\n```bash\n sudo chmod 777 000-default.conf[혹은 디렉토리]\n```\n\n> 000-default.conf 를 아래처럼 편집한 후 저장\nvi 명령어를 사용해서 즉석으로 편집해도 되고 파일질라같은 ftp 응용프로그램을 이용해서 로컬에서 작성하고 덮어쓰기해도 좋다.\nvi 명령어일 경우 저장하고 나가기는 esc + :wq!이다\n\n```bash\n#LoadModule 구문을 써 줘야 ProxyPass가 작동한다. 이거 미리 설정하면 아래 파일을 실행시키는 스크립트 작성할 필요 x\nLoadModule proxy_module modules/mod_proxy.so\nLoadModule proxy_http_module modules/mod_proxy_http.so\n\n<VirtualHost *:80>\n\tServerAdmin webmaster@localhost\n\tDocumentRoot /var/www/html\n\n\tServerName yourdomain.com\n\tServerAlias yourdomain.com\n\n\tProxyRequests Off\n\tProxyPreserveHost On\n    # 80으로 받으면 아래 주소로 넘긴다. 여기서의 로컬호스트는 apache가 돌아가는 컴퓨터의 로컬호스트.\n\t#주소창에서 보여지는 주소도 서버네임으로 바뀌어서 보여진다.\n  \tProxyPass / http://localhost:8080/\n  \tProxyPassReverse / http://localhost:8080/\n\n\tErrorLog ${APACHE_LOG_DIR}/error.log\n\tCustomLog ${APACHE_LOG_DIR}/access.log combined\n\n    RewriteEngine on\n    RewriteCond %{SERVER_NAME} =content-ad-dev.fastview.co.kr\n    RewriteRule ^ https://%{SERVER_NAME}%{REQUEST_URI} [END,NE,R=permanent]\n</VirtualHost>\n```\n\n### 3. Apache2 서비스 재가동\n```bash \nsudo service apache2 restart\n```\n\n### 4. Snap 설치(이미 깔려 있으면 생략)\n```\nsudo snap install core; sudo snap refresh core\n```\n\n### 5. Snap으로 Certbot 설치\n```\nsudo snap install --classic certbot\n```\n\n### 6. Apache 사양으로 인증서 발급(apache2 서비스가 가동 중이고 80포트가 뜷려있어야 함)\n```\nsudo certbot --apache\n```\n머라머라 나오는데 읽어보면 도메인 입력해달라는것과 인증서 만료 시 발송할 이메일좀 설정해달라는 내용\n그리고.. 뭔가를 보낸다는 내용인데 이 항목은 생략해도 됨\n\n만약 과정이 꼬여서 000-default.conf를 다시 수정해야 하면, 인증서파일 재설정을 하면 된다.\n\n인증서가 이미 존재할 때 위 명령어를 입력하면 인증서 목록이 뜨는데 원하는 도메인의 번호를 입력한다.\n\n```bash\n1: Attempt to reinstall this existing certificate\n```\n\n해당 항목을 선택하면 Certbot의 인증서 파일(000-default-le-ssl.conf)이 다시 갱신된다.\n\n### 7. 확인\n\n웹페이지에 접속해서 자물쇠 표시가 뜨면 성공!","tags":["certbot","배포","https","인증서","apache"],"categories":["linux"]},{"title":"Hexo 배포 커맨드와 커스텀 도메인에 관한 이슈","url":"/post/clgyf00n6000d685o7y8x5pdc/","content":"\n### 문제점\n 기존 도메인에서 블로그 전용 도메인을 구매하고, 깃허브 페이지에 연결해 놓았었는데\nHexo로 만든 블로그 프로젝트에서 <code>hexo deploy</code> 커맨드를 이용해 배포하면\n깃허브 페이지의 퍼블리싱된 커스텀 도메인이 초기화가 되는 이슈가 발생했다.\n\n### 해결\n이를 해결하려면 hexo 의 블로그 프로젝트 source 폴더에\nCNAME 파일을 생성하고, 안에 퍼블리싱할 커스텀 도메인을 입력한다.\n\n![cname_file](/img/postimg/cname_file.png)\n\n이후 <code>hexo deploy</code> 커맨드를 입력하여 배포해도 깃허브 페이지의 커스텀 도메인이 해제되지 않는다.","tags":["배포","github_page","hexo","issue","custom_domain","hexo_deploy"],"categories":["Hexo"]},{"title":"Github Page에 커스텀 도메인 연결하기","url":"/post/clgyf00n40007685o4bpf129j/","content":"\n# Github Page에 커스텀 도메인 연결하기\n방법은 다음과 같다.\n\n### 도메인을 구입한 사이트에서 깃허브 리포지토리 주소를 CNAME으로 추가 또는 변경해주기\n도메인을 구입한 사이트에서 있어야 할 레코드는 다음과 같다.\n\n|레코드명|이름|데이터|\n|------|--|-----|\n|CNAME|www|[yourRepo].github.io|\n|A|@|185.199.108.153|\n|A|@|185.199.109.153|\n|A|@|185.199.110.153|\n|A|@|185.199.111.153|\n\n네임서버는 따로 이관하지 않아도 된다.\n\n### 블로그로 서비스되고있는 깃허브 페이지의 리포지토리 => Setting => Page\n\n![커스텀 도메인](/img/postimg/custom_domain.png)\n\nsave를 누르면 위에 등록한 DNS정보가 모두 올바를 경우 해당 주소로 퍼블리시되었다는 알람을 띄운다.\n\n아래 체크박스를 보면 알 수 있지만 GithubPage 특성상 https 옵션을 활성화할 수 있다.\n\n도메인으로 접속했을 때 깃허브 페이지가 뜨면 성공!\n","tags":["dns","github_page","domain"],"categories":["기타"]},{"title":"Hexo 테마 만들기","url":"/post/clgyf00n6000h685o7zpxa950/","content":"\n# Hexo 테마 구축하기\n\n#### 들어가며\nHexo 에서 기본적으로 제공하는 기본값 레이아웃 icarus의 소스가 많이 도움이 되었다.<br>\nHexo 는 블로그 '프레임워크' 이며, 공식 문서에서는 helper라는 이름으로 렌더링 스크립트도 제공한다. 용어가 생소해서 많이 헤맸던 기억이 난다.\n헬퍼에서 제공하는 스크립트는 서버사이드 혹은 클라이언트 사이드 렌더링처럼 뷰 엔진 파일 위에서 사용할 수 있다. 해외에서 안내하는 방법대로 테마를 만들어보고, 정리해보고자 이렇게 게시물을 작성하게 되었다.<br>\n\n### 목차\n* 테마 폴더 만들기\n* layout 파일 만들기\n* 기본 페이지 추가하기\n    * index\n    * archive\n* 부분 렌더링(페이지 쪼개기)\n* 정적 소스 불러오기\n* 만든 테마 적용하기\n* 테마가 적용된 블로그 배포하기\n* 테마 만들기 심화\n    * 부가 페이지 만들기\n    * 댓글 위젯 달기(utterances)\n    * 손수 위젯 만들기\n    * 커스텀 404 페이지(github)\n\n## 테마 폴더 만들기\nHexo init을 실행하고 나서, 프로젝트의 루트 경로 아래에 themes 폴더를 만든다.\n\nthemes 폴더 하위에 테마 이름을 짓고 영문명으로 폴더를 생성한다. ex)your-theme-name\n\nyour-theme-name 폴더 하위에도 _config.yml 파일을 만든다.\n\n> Hexo는 _config.yml을 환경변수 겸용 클라이언트딴 전역변수처럼 사용할 수 있는데, <br> \n테마 하위에 있는 _config.yml은 이 테마에서만 특별하게 적용되는 환경변수값을 지정해서 사용한다.\n\n[your-theme-name]폴더 하위에 렌더링 형태를 결정할 layout 폴더와, 테마의 정적 리소스들이 들어갈 source 폴더를 만든다.\n\n#### 요약\n> 1. themes 폴더 > [your-theme-name] 폴더 생성\n> 2. 하위에 layout/source 폴더, _config.yml 만들기\n\n## layout 파일 만들기\n폴더 구조를 잡았으면, [yout-theme-name]/layout 폴더 하위에 이제 페이지 골격을 이루는 파일을 만들어야 한다.\nHexo는 서버사이드 렌더링이나 클라이언트 사이드 렌더링을 할 때처럼 부분 렌더링을 지원한다.\n이는 ejs나 pug 같은 뷰 엔진을 통해 이루어진다.\n\n특히 layout 파일은 테마의 전반적인 레이아웃을 결정한다.\n메인 페이지, 블로그 페이지, 아카이브 페이지로 이동할 때, layout 파일 구조에 베이스를 잡고 하위에 페이지를 그린다.\n\n> 페이지별로 아예 다른 레이아웃을 적용하고 싶다면, 상위로 먼저 참조하는 layout을 이에 맞게 작성해야 한다.\n\n테마 폴더의 구조를 잡았으면 이제 렌더링할 뷰 엔진을 선택한다.\nnode.js를 하는 사람이라면 익숙한 뷰 엔진인 ejs 도 채택할 수 있다.\nejs를 사용한다면, 이에 맞는 layout 파일을 만든다.\n\n![layout 파일 구조](/img/postimg/layout01.png)\n\nbody 부분에 페이지가 이동될 때 페이지에 맞는 부분 레이아웃이 그려진다.\n\n## 기본 페이지 추가하기\nlayout 파일을 작성했다면, 페이지의 레이아웃을 추가한다.\n### index\n사이트에 진입했을 때, 가장 먼저 보여지는 페이지의 레이아웃은 index 페이지 레이아웃을 따른다.\n### archive\n아카이브 페이지는 주제별 카테고리 및 기간별 아카이브를 선택했을 때 그려지는 레이아웃이다.\n\n## 부분 렌더링(페이지 쪼개기)\nHexo는 앞서 말했듯이 뷰 엔진을 통한 부분 렌더링을 지원한다.\n페이지 레이아웃에 통째로 작성해도 좋지만, 반복되는 구조 등이 있다면 partial 이라고 컴포넌트화 해서 위젯 붙이듯 붙여넣는 방법을 채택할 수도 있다.\n이는 _partial 폴더 하위에 작성해서, partial 키워드로 렌더링 코드를 작성하면 된다.\n\n![테마 폴더의 내부 구조](/img/postimg/folder_structure.png)\n\n![작성한 partial 을 다음처럼 적용한다](/img/postimg/layout01.png)\n\n## 정적 소스 불러오기\nsource 폴더는 프로젝트의 루트에도 있고, 테마 내부에도 있다.\n\n테마 내부의 source 폴더는 블로그 포스팅에 사용되는 img 나 css, js 파일과 같은 정적 리소스를 두는 데에 사용한다.\n\n![테마 내부의 source 폴더 안에는 정적 리소스가 들어간다](/img/postimg/theme_source_folder.png)\n\n## 만든 테마 적용하기\n테마의 _config.yml이 아닌 프로젝트 루트 위치의 _config.yml에서 theme 명을\n작성해 두었던 theme 명으로 변경한다.\n변경사항을 저장하고 Hexo server를 가동하면 적용된 테마를 확인할 수 있다.\n\n## 테마가 적용된 블로그 배포하기(github)\nHexo에는 배포 자동화 플러그인이 있다.\ngithub에 배포하려면 hexo-deploy-git 플러그인을 사용하자.\n프로젝트 루트의 _config.yml에서 deploy관련 설정을 작성해준다.\n![깃허브 배포 yml 설정](/img/postimg/github_deploy_yml.png)\n\n## 테마 만들기 심화\n### 부가 페이지 만들기\nhexo new page [페이지명] 커맨드를 하면 프로젝트 루트의 source 폴더 내부에 [페이지명]으로 된 폴더가 생기는데, 페이지 주소를 받기 위해 index.md 가 내장되어 있다.\n\n프로파일처럼 아무 내용이 없더라도, 페이지는 만들어지며 .md 의 yml 부분에서 레이아웃을 설정해주지 않으면, 테마의 index.ejs의 레이아웃으로 적용된다.\n\ntheme에서 부가적으로 만들 페이지의 레이아웃을 설정해준다.\n\n예시로 guest 나 prologue 등 부가적인 ejs를 생성한다.\n\n해당 테마는 guest나 prologue라는 이름의 레이아웃이 생기게 되며,\n프로젝트 루트 폴더/source 내부의 페이지 이름으로 된 폴더 내부의 index.md의 layout 값을\n해당 페이지의 layout 이름으로 지정해준다.\n\n서버를 가동하면 페이지에 레이아웃이 적용된 걸 확인할 수 있다.\n\n### 댓글 위젯 달기(utterances)\n포스트 페이지 아래에 utterances 플러그인을 삽입한다.\n\ngit 이슈와 연동하는 권한을 utterances에게 부여해야 한다.\n\nHexo 게시물의 퍼머링크와 해당 플러그인을 바인딩하면 각 포스트에 댓글을 달 때마다\n포스트별로 이슈가 생성되고, 알람을 받아볼 수 있다.\n\n### 손수 위젯 만들기\npartial 키워드가 부분 렌더링하는 걸 이용하여 위젯을 만들 수 있다.\n* 최근 포스트\n* 포스트의 내용 트래커\n* 카테고리 메뉴\n* 태그 클라우드 메뉴 등\n\n### 커스텀 404 페이지(github)\n배포를 깃허브에 하는 경우 source 폴더 바로 아래에 404.html 을 만들어 넣어두면\ngithub에서 링크를 찾지 못할 때마다 404.html 로 리디렉션시킨다.\n\n잘 꾸며서 넣어두면 따로 라우팅을 설정할 필요가 없어 편리하다.\n\n\n\n","tags":["hexo"],"categories":["Framework","Hexo"]},{"title":"SSH키로 로그인하는 법","url":"/post/clgyf00n7000m685of33c30xn/","content":"## SSH키로 로그인하는 법\n### SSH 키 생성하기\n깃허브나 벌쳐 인증서버/원격 데이터베이스에 접속할 때 키로그인을 필요로 하기도 한다.\n>키 생성하기\n```cmd\nssh-keygen\n```\n모든 설정 기본값으로 하면 내 컴퓨터/사용자 폴더/.ssh폴더(숨겨진 폴더)안에 다음처럼 rsa 키가 생성된다.\n- id_rsa\n- id_rsa.pub\n\n### 키 파일 등록\nssh 를 이용해서 로그인하려면 이전 과정에서 생성된 두가지 키가 필요하다.\n\n- id_rsa (클라이언트 피시가 가지고 있을 프라이빗 키. 이걸로 로그인함!)\n- id_rsa.pub (호스트에 등록할 퍼블릭 키. 긁어서 호스트에 등록해야한다.)\n\nid_rsa는 다른 이름이거나 확장자가 <code>.ppk</code> 또는 <code>.pem</code>일 수 있다.\n\n> .ssh 안에 프라이빗 키를 집어넣고, 퍼블릭 키는 파일을 열어 내부를 긁어서 호스트에 등록한다.\n\n### SSH 원격 접속 Config 파일 작성\n>터미널 원격 ssh 접속 시 간편 커맨드를 위한 .ssh/config 파일을 설정한다.\n``` bash\nHost [ConnectionName]\n\tHostName [HostIP]\n\tUser [HostLoginID]\n\tIdentityFile ~/.ssh/[YOUR_PRIVATE_KEY_FILE]\n```\n\n위처럼 만들어 저장해 놓으면\n```\nssh [ConnectionName]\n```\n으로 간편하게 접속할 수 있다.\n\n키 파일 위치만 올바르다면 별도의 패스워드를 요구하진 않는다.\n\n### 기타 파일변환\n\n>putty .ppk파일을 제네릭한 .pem으로 변환(윈도즈 putty가 있으면 ppk 그대로 사용해도됨)\n- Mac 인 경우(선제 homebrew 설치 필요)\n``` bash\nbrew install putty \nputtygen 원본.ppk -O private-openssh -o 내보낼.pem\n```\n- Windows인 경우 putty-keygen exe를 이용한다.\n","tags":["ssh","terminal","cmd","bash"],"categories":["linux"]},{"title":"pm2와 클러스터화","url":"/post/clgyf00n8000t685ocpdu5c6i/","content":"## 클러스터화 가동 설정 및 디버깅\nNode.js의 루트 바로 아래에 있는 인덱스 파일들은 package.json 설정 등을 통하면 멀티스레드로 실행할 수 있다.\n>package.json 파일 설정과 pm2를 이용하여 별개의 프로그램을 클러스터화 가동한다.\n\n### 1. pm2 npm 모듈 글로벌 옵션으로 깔기(클러스터 작동 확인을 위한 도구)\n``` bash\nnpm install pm2 -g\n```\n\n### 2. 클러스터화 파일 작성\n  각 클러스터의 dev 실행 명령어 지정 및 클러스터화 시동 명령어 지정(package.json)\n> package.json 작성 예제. daum/blog/post는 각기 실행할 별개의 index.ts파일이라고 보면 됨.\n``` json\n\"scripts\":{\n    \"start:cluster\": \"pm2-runtime pm2.config.js\",\n    \"dev:post\": \"nodemon --legacy-watch --watch ./ --exec 'npx' ts-node -r tsconfig-paths/register ./src/post.ts\",\n    \"dev:blog\": \"nodemon --legacy-watch --watch ./ --exec 'npx' ts-node -r tsconfig-paths/register ./src/blog.ts\",\n    \"dev:daum\": \"nodemon --legacy-watch --watch ./ --exec 'npx' ts-node -r tsconfig-paths/register ./src/daum.ts\",\n    \"dev\": \"npm run dev:blog & npm run dev:daum & npm run dev:post\",\n    \"build\": \"tsc -p tsconfig.json && tsc-alias\",\n}\n```\n> pm2.config.js 작성 예제. 클러스터화를 할 설정파일들을 지정한다. 인스턴스 갯수만큼 생성이 됨.\n``` javascript\nmodule.exports={\n    apps:[\n        { name: \"post\", script: \"./dist/post.js\", instances: 1, exec_mode: \"cluster\" },\n        { name: \"blog\", script: \"./dist/blog.js\", instances: 1, exec_mode: \"cluster\" },\n        { name: \"daum\", script: \"./dist/daum.js\", instances: 1, exec_mode: \"cluster\" },\n    ]\n}\n```\n \n### 3. 빌드하기\n>타입스크립트 파일들이 js로 빌드된다.\n```bash\nnpm run build\n```\n\n### 4. 클러스터 가동\n> package.json에서 선제 명령어 설정을 해줘야 함\n```bash\nnpm run start:cluster\n```\n\n### 5. 이후 디버깅은 pm2 에서 할 수 있음\n> 가동되고 있는 클러스터 확인\n```bash\npm2 list\n```\n\n> 클러스터 상세내역 확인(방향키로 조정)\n```bash\npm2 monit\n```\n\n>클러스터 가동 취소\n\nnpm run start:cluster 명령어를 쳤던 커맨드창 ctrl+c \n\n이렇게 취소하면 pm2 list 했을 때 생성되었던 클러스터들이 사라진 것을 볼 수 있다.\n","tags":["pm2"],"categories":["javascript"]},{"title":"함수의 비동기화와 async 키워드","url":"/post/clgyf00nf003i685o0cbk8ar2/","content":"\n# 함수의 비동기화\n\n기존 async await 를 단순히 비동기를 순차적으로 처리하는 데에만 이용하다가,\n실무상 비동기로 함수를 처리해야 할 일이 생겼다.\n>일반적인 자바스크립트 함수\n\n``` javascript\nfunction (){\n    //그냥 함수\n}\n```\n자바스크립트 특성상 비동기 함수의 경우 일반 함수에서 호출 시 실행하라는 오더만 내리고 바로 다음 항목을 진행한다.\n\n>비동기를 동기적으로 처리할 때, async await 의 사용법.\n```javascript\nfunction somePromiseFunc(){ //Promise 반환 함수인 somePromiseFunc.\n    return new Promise((resolve,reject)=>{\n        try{\n         //input do something..\n         resolve(async_logic_result)\n        }catch(err){\n         reject(err)\n        }\n    })\n}\n\nasync function(){ //async await 의 일반적인 사용.\n    let result = await somePromiseFunc() //비동기 함수의 응답을 받기 위해 await를 사용\n    //do other func\n    return result;\n}\n```\nasync await 는 비동기 처리함수를 동기적으로 처리할 때 쓰이는 문법이다.\nawait는 async를 선언한 함수 내부에서만 쓸 수 있으며, Promise 를 반환하는 함수에 써서 result 변수에 resolve 내부에 들어가있는 결과값을 받을 수 있다.\n\n\n평소에 이렇게 비동기를 동기적으로 수행처리하는 과정만 생각하는게 주인데, 이번에는 업무상 응답속도를 줄이기 위해 의도적으로 함수를 비동기화해야하는 것이었다.\n\n> 실무에선 300줄 이상의 무거운 쿼리는 수행하라는 명령만 내리고, 문자열처럼 생성이 빠른 것들은 빨리 생성해서 바로 200 응답을 전송하길 원했다.\n\n이 방법을 찾는 과정에서 각 실행 방법의 응답속도를 비교했고, 더불어\nasync-await 키워드의 새로운 기능을 알게 되었다.\n\n<br>\n\n# 속도 비교\n\n## 1. 일반 실행\n```javascript\nfunction someHeavyFunc(){\n    //무거운 쿼리 로직. query를 때릴 때 사용하는 모듈 자체는 비동기식으로 작동한다.\n}\n\nfunction callAsyncFunc(){\n\n    let fast_key = otherModule.keyMaker(someInput); //빠른 실행이 가능한 함수\n\n    someHeavyFunc()\n\n    let fast_answer={\n        key:fast_key\n    }\n\n    return fast_answer\n}\n```\njavascript는 기본적으로 비동기로 작동한다고 하지 않았었나..? 하지만 Postman과 console.log로 각 함수 실행과정과 응답속도를 테스트한 결과, 200 응답 뒤에 무거운 함수가 실행되는 경우는 없었다.\n\n\n![default_do](/img/postimg/default_do.png)\n거진.. 요청당 약 1초가 걸린다. 어마무시하다.\n\n## 2. setTimeout 함수\n두 번째로는 비동기 함수의 개념을 배울 때 주로 사용하는 setTimeout으로 테스트하였다.\n\n```javascript\nfunction someHeavyFunc(){\n    //무거운 쿼리 로직..\n}\nfunction callAsyncFunc(){\n\n    let fast_key = otherModule.keyMaker(someInput); //빠른 실행이 가능한 함수\n\n    setTimeout(function(){\n        someHeavyFunc()\n    },50) //비동기 처리를 위해서는 어쩔 수 없나...? 근데 진짜 이렇게?\n\n    let fast_answer={\n        key:fast_key\n    }\n\n    return fast_answer\n}\n```\nasync 키워드를 함수 앞에 붙인다는 게 무슨 뜻인지 제대로 알지 못해서 생긴 폐해다(...)\n\n![settimeout_do](/img/postimg/settimeout_do.png)\n응답속도가 많이 줄었다. setTimeOut 함수가 비동기 함수인 걸 알고 return을 먼저 보내고 무거운 함수를 실행한 것이다. 속도 개선은 되었지만, 당연스럽게도 setTimeOut함수를 사용하면 초반지연이 발생한다.\n\n앞서 실험했던 일반 실행과 비교해봤을 때, 이는 js가 봤을 때 함수가 비동기임을 몰라서 생기는 상황인 것 같았다.\n\n* 그러면 어떻게 비동기 함수인걸 알려줘야할까?\n\n답은 async-await 페어 중 async에 있었다.\n\n\n## 3. async 키워드\n\n> async 키워드는 함수를 비동기 취급한다.\n```javascript\nasync function someHeavyFunc(){\n    //무거운 쿼리 로직..\n}\nfunction callAsyncFunc(){\n\n    let fast_key = otherModule.keyMaker(someInput); //빠른 실행이 가능한 함수\n\n    someHeavyFunc()\n\n    let fast_answer={\n        key:fast_key\n    }\n\n    return fast_answer\n}\n```\n무거운 함수 앞에 async를 붙이고, 무거운 함수를 호출하는 함수는 async 키워드를 붙이지 않는다.\nasync 키워드를 붙이지 않았으니, await도 쓸 수 없다.\n결과는 어떨까?\n\n![async_do](/img/postimg/async_do.png)\n\n성공이다! 원하는 응답도 제대로 가져온다.\n\n# 응용\n... 그러면 특정 부분은 비동기로 수행하고 비동기 함수끼리는 동기적으로 처리하고 싶을 때, 이렇게 하면 된다.\n\n```javascript\nfunction caller(){ //caller는 일반 함수\n\n    let faster = doMakeFaster() //일반 함수\n\n    async function doAsync(){ //비동기로 묶어서 처리할 랩퍼를 선언\n        let result1= await someAsyncFunc() //비동기 함수를 순차적으로 시행\n        await someAsyncFunc2(result1) //비동기 함수를 순차적으로 시행\n    }\n\n    doAsync() //비동기로 시행\n\n    return faster;\n}\n```\nfaster 먼저 변수에 결과값이 담기고, doAsync()는 명령만 내린 뒤 바로 return 값을 반환한다. 이후 doAsync() 함수 수행 명령을 내린 시점에서 someAsyncFunc()와 someAsyncFunc2가 순차적으로 실행된다.\n\n\n비동기 처리를 동기적으로 수행하기 위해 여태껏 await에만 초점을 맞추고 있었는데, 이번엔 await를 사용하지 않고 async만 사용해 보았다.\nasync-await는 기본적으로 페어지만, 함수를 비동기로 실행할 때도 있는 법이다.\n두 키워드를 좀더 제대로 알게 된 것 같아 기쁘다. 유익한 경험이었다.","tags":["비동기","asyncawait","postman","속도 개선"],"categories":["javascript"]},{"title":"블로그 새단장","url":"/post/clgyf00n90010685odili48j5/","content":"기존 블로그 레이아웃과 테마를 새로 리뉴얼했다!\n깔끔해서 마음에 든다.\n\n이번에 새 테마를 만들면서, 기존 Hexo 공식 문서를 많이 파악해 보는 시간을 가졌다.\n조만간 레이아웃 만들기도 정리해서 포스팅할 예정.","tags":["잡담"],"categories":["기타"]},{"title":"링크 스크랩 및 참고자료","url":"/post/clgyf00n9000z685oco643r66/","content":"\n\n### 리눅스 명령어들\n\n``` sudo grep -ir 'bind-address' /etc/mysql/ ```\n해당 위치에 원하는 텍스트가 있는 파일을 찾는 명령어\n\n```iptables -I INPUT -s 1.1.1.1 -j DROP```\n특정 IP막기\n\n> https://thisblogbusy.tistory.com/entry/iptables-특정-IP-막기?category=692140 \n\n```cat /var/log/apache2/access.log```\n\n```tail access.log```\n접속 기록 확인\n\n```nohup npm start &```\n노헙으로 종료가되어도 계속 실행되도록 백그라운드로 npm start실행.\n\n\n### https 인증\n\n호스트 서버컴퓨터에 snap 깔고 certbot 깔고\n\n```certbot --apache```\n\n리버스프록시로 아파치를 설정해뒀다면 아파치 사양으로 certbot이 자동으로 인증서를 설정해줌.\n\n\n### ip 접속기록 확인 (아파치 이용)\n\n```sudo awk '{ print $1}' /var/log/apache2/access.log | sort | uniq -c | sort -nr | head -n 10```\n접속기록 빈도 10위까지 출력\n\n### ssh 키페어 등록하기\n\n> https://extrememanual.net/26803\n\n1. puttygen 이용, rsa 키페어 생성\n\n2. 퍼블릭키와 프라이빗키 저장\n\n3. 호스트 서버 들어가서 유저계정 고유 폴더에 .ssh 폴더 만들기\n\n```mkdir .ssh```\n\n```vi .ssh/authorized_keys```\n\n4. 해당 편집기에 public key 부분을 텍스트 붙여넣기 후 저장\n\n\n\n### 드래그앤드롭 라이브러리\n\n> https://interactjs.io/\n\n> https://web.dev/drag-and-drop/\n\n드래그앤드롭 파일 업로드 및 설명 튜토리얼.\n\n\n\n### Electron 시작하기\n\n> https://musma.github.io/2019/07/17/electron-getting-started.html\n\nElectron을 이용해서 node.js 와 js로 데스크톱 어플리케이션을 만들 수 있다.","tags":["스크랩"],"categories":["기타"]},{"title":"Certbot으로 https 서브도메인 등록하기","url":"/post/clgyf00n10001685oav5hdb51/","content":"\n시행착오가 좀 많았다.\n\n회사서 홈페이지를 새로 구축했다. 구축하는 김에 구식이었던 정적 호스팅을 버리고.. 서버도 올릴 수 있도록 요즘 클라우드 호스팅으로 갈아탔다!\n\nAWS EC2처럼 가상컴퓨터지만.. 클라우드라서 훨씬 가격이 저렴하다.  (사실 써본 입장으로써 AWS는 좀 깡패라는 생각이 든다 가격 측정상...ㅡ,.ㅡ)\n\n클라우드 중 가장 싸다는 Vultr호스팅을 이용하고 싶었으나.. 회원가입할때 1인 1계정 원칙이 있는데, 하필이면 잘 모르는 초짜 고고넛이 회원가입할 때 실수를 해서 락이 걸렸다. \n\n문의 처리는 빨랐지만  Vultr가 해외 호스팅 서버라 처리하는게 좀 번거로워서..  고심한 끝에,\n\ncafe24의 클라우드 호스팅 서비스를 이용하기로 결정했다.\n\n가격도 Vultr 랑 비교해서 둘이 비슷하다! 성능은 cafe24 클라우드 호스팅 쪽이 램을 더 잘 지원하고.. 용량이 쪼끔 더 작다.(벌쳐는 램이 작고 용량이 큰 편) 그리고.. 벌쳐는 클라우드 서버를 사면 공인 IP도 같이 주는데 cafe24쪽은 공인 IP를 따로 사야한다.\n\n사내 홈피처럼 공적인 부분은 공인 IP가 꼭 필요하므로~ 공인 IP도 클라우드 서버와 같이 구매했다.\n\n\n\n개인 블로그 구축을 경험삼아 Ubuntu 18 바이오닉 서버에 Node.js Express서버를 배포하려고 했다.\n\ncafe24클라우드의 특성상 보안을 위해 SSH키를 사용해야만 접속할 수 있고,\n\nSSH 키는 cafe24클라우드가 서버 살 때 키까지 만들어준다.\n\n\n\nSSH 키로 접속할때 고고낫은 Putty를 이용했으므로, 키를 읽어서 변환해주는 puttygen이 필요했다.\n\n홈피서 pem 키를 받고 puttygen에서 불러오기를 하면 exe프로그램이 putty전용으로 key를 변환해준다.\n\nsave Private Key를 하면 ppk로 내려지는데,\n\nPutty > Connection > SSH > Auth 에서 맨 밑 항목을 보면 Private key file for authentication 하고 ppk키를 등록하는 부분이 있다.\n\n\n\n푸티에도 등록해주고, 파일질라에도 상단의 사이트 관리자 항목을 보면 키를 등록해주는 부분이 있다.\n\n\n\n> ❕  Putty 와 Filezila 연결을 위한 방화벽 설정은 cafe24 클라우드 웹콘솔 화면에서 사람이 정말~ 설정하기 쉽도록 되어 있다. ufw 치고.. 막 콘솔 창 안 들여다봐도 된다 ㅎㅎ\n\n\n\n여튼 key를 이용해서 putty로 ssh접속하면, 지정된 계정 이름으로 접속하게 되어있는데, 이 계정한텐 root권한이 없어서 명령수행 할 때 일시적으로 제약을 해제해줘야 했다.\n\n<code>sudo -i</code>\n\n파일질라로 배포할 파일 업로드하는 과정은 생략한다. Express(Node)는 일종의 SSR서버이므로~ 직접 접근하게 하면 좀 위험하고 정적 서버인 apache를 통해 프록시하면 좋을 것 같아서 apache2도 깔았다. 프록시설정하는 과정도 생략한다!\n\n인터넷 상으로 접속 확인하고 ip도메인 연결하고 도메인 주소를 치면 사이트가 다 뜨는 것까지 확인했다.(다만 http일 뿐이지..)\n\n\n\n### 본론!\n\n서론이 쫌 길었다.. 클라우드 얘기만 대판 ..ㅡ.ㅡ) 이제 https를 등록할 차례인데,\n\nCertbot이 너무 친절한게.. 공식 사이트 가서 서버 종류랑 컴퓨터 운영체제를 입력하면 어떻게 깔아야 하는지 튜토리얼이 너무 잘 되어있다...ㅠ.ㅠ\n\nhttps://certbot.eff.org/lets-encrypt/ubuntubionic-apache\n\n아파치 사양으로 하라는 대로 했다. 여기까진 아무 문제 없었다. 근데 왠걸.. 선택지가 두개 뜨는데, 한 도메인은 www를 포함하고, 다른 한 도메인은 www를 포함하지 않는 도메인을 보여주면서 둘 중 인증서 발급 받을 주소를 하나 택하라고 한다\n\n\n\n둘다 발급받을건데.? 하고 서트봇 인증서 발급 명령을 두번 실행하면\n\n인증서는 두개인데.. 사이트 들어가서 확인해봤더니만,\n\n정작 적용은 맨 마지막에 발급받은 인증서 하나만 되는 것 같았다.\n\n\n\n여기서 좀 많이 해멨는데, 방법은.. 인증서를 하나만 발급받고 (www든 www가 아니든)\n\n아래처럼 서브도메인으로 인증서를 확장하는 명령을 내리는 것이었다.\n\n<code>certbot --expand -d existing.com,example.com,newdomain.com</code>\n\n이렇게 하면 하나의 인증서 아래에 여러 서브도메인이 붙는다.\n\n여튼 이걸로 도메인 여러개 발급받는 것 해결했음...\n\n","tags":["certbot"],"categories":["Framework","Express"]},{"title":"Hexo와 API 서버 간의 통신","url":"/post/clgyf00n6000e685o9oem1x8n/","content":"\nHexo 블로그에 서버 API를 이용하는 덧글 위젯을 직접 만들고 싶다면 참조할 수 있는 포스팅이다.\nHexo는 정적 웹 블로그를 빠르게 작성할 수 있도록 하는 데에 주요 목적이 있기 때문에, 쿼리를 통해 데이터를 가져오고 서버통신을 통해 html dom을 렌더링하는 로직에 대한 지원은 그다지 좋지 않다.\n Hexo 공식 사이트에서 지원하는 플러그인, 또는 Disqus나 Utterances 와 같은 덧글 위젯이 있지만.. 이런 위젯은 커스터마이징이나 데이터 저장 방식이 유연하지 못하다는 게 사실이다.\n\n요약해서 말하자면, 결국 개발자들의 입맞에 맞지 않기 때문에 커스텀 위젯을 만들고자 하는 것이다 ^^;;\n\n> 뭘 만들 것인가?\n\nHexo처럼 정적 프레임워크와 같이 사용할 수 있는, 덧글 위젯을 만들려고 한다.\n\n> 어떻게 만들 것인가?\n\nHexo와 호환되려면 어떻게 해야 할까?\nHexo는 정적 블로그형 웹페이지 제작에 최적화된 별도의 서버를 가지고 있다. 이 서버는 Hexo를 가동시킬 때 .md(마크다운) 파일을 html로 내려준다.\n\n*문제점 : Hexo와 위젯 API서버가 다르기 때문에 크로스오리진 이슈가 발생한다.\n\n:할 수 있는 방법\n> 위젯 따로 구동되는 방식을 이용해야 한다. 다른 웹페이지를 볼 수 있는 iframe 태그를 이용할수도 있고, 데이터만 전송받아 Hexo 상에서 DOM을 따로 그릴 수도 있다. 데이터 교환 방식은 ajax 또는 axios를 이용할 것이다.\n\n흐름 구상은 다음과 같다.\n1. Hexo에서 ajax 혹은 axios를 이용하여 데이터를 요청한다.\n2. api를 통해 댓글 데이터를 전송한다.\n3. 전송된 데이터를 받아서 Hexo상에서 HTML DOM을 직접 그린다.\n\n..해서 다음과 같은 과정이 될 것이다.\n\n* Hexo ajax 요청 => 위젯 API의 수신 및 응답 => Hexo ajax 응답 완료 => Hexo의 js로 DOM 렌더링\n\n> 그렇다면 이제 뭘 이용해서 구현할까?\n\n페이지를 렌더링해서 iframe하는 방식도 해봤고 데이터만 받아와서 hexo상에서 렌더링하는 방식도 해봤는데\niframe은 크로스오리진 이슈 때문에 iframe 내부의 DOM을 조작하기가 까다로워서 ajax 요청을 통해 api 서버로부터 데이터를 받아와서\nHexo 측에서 댓글 위젯을 그리는 편을 택했다.\n\n### 1. Node.js Express 프레임워크로 위젯이 가동될 서버 만들기\n<!-- 이미지 -->\nexpress를 사용하여 api 서버의 틀을 잡는다.\n<!-- 이미지 -->\n댓글이 저장될 데이터베이스 또한 작성해야 한다.\n### 2. 위젯 서버의 API 로직 작성하기\n<!-- 이미지 -->\nNode Express 서버에 기본 CRUD를 할 수 있도록 기능을 만든다.\n### 3. Hexo ajax 요청 로직 작성\n<!-- 이미지 -->\nHexo 댓글 위젯의 버튼을 누르면 ajax 또는 axios 를 통해 위에서 작성한 api에 데이터를 요청할 수 있도록 한다.\n### 4. 댓글 DOM 렌더링 로직 작성\n<!-- 이미지 -->\n데이터 전송이 끝나면 추가되는 댓글 또는 삭제되는 댓글을 렌더링할 수 있도록 html DOM 렌더러를 작성한다.\n### 5. 댓글이 갱신되는것을 확인\n<!-- 이미지 -->\n댓글이 잘 작성된 것을 확인할 수 있었다.\n지금은 익명 댓글이지만, 로그인 위젯을 만들어 놓으면 api 서버로부터 세션검증을 통해 유저검증을 하는 것도 가능할 것 같다.\n","tags":["hexo"],"categories":["Framework","Hexo"]},{"title":"Hexo 테마 블로그 적용기","url":"/post/clgyf00n7000i685oe8ui018p/","content":"\n블로그의 첫 게시물은 도커가 장식했지만, 그래도 명색이 헥소로 기껏 만든 블로그인데 적용기를 써보자~ \n다른 블로그를 봐도 헥소 테마 레이아웃을 만드는 방법은 잘 나와있지 않아서, 이왕 하는 김에 테마 만드는 법도 같이 기술하련다.\n헥소 프레임워크를 좀 만져봤는데, 작동원리는 쪼끔 알겠고 헥소 기반 테마 만드는법을 모르는 사람에게 추천한다. 헥소 공식 사이트에도 만드는 방법이 어렴풋하게나마 나와있으니 참조해도 좋다(그리 자세히 나와있진 않지만..)\n\n### 1. 레이아웃 폴더 만들기\n\n우선... 블로그 폴더 구조는 다음과 같다.\n\n![blog_structure](/img/postimg/blog_structure.png)\n\n먼저  프로젝트 루트 폴더에 themes 폴더를 만들고, 내부에 자기가 만들 테마의 이름을 짓자.\n이 안에 블로그 틀이 들어갈 📁layout 폴더와 img/js/font처럼 정적 소스들이 들어갈 📁source 폴더를 만든다.\n블로그 테마에 적용시킬 변수들을 모아 관리하는 <code>_config.yml</code>파일도 만든다.\n\n### 3. 렌더링할 템플릿 엔진 선택\n필자는 Express를 사용해와서.. 상대적으로 익숙한 ejs로 작성할 것이다.\n블로그의 전체 레이아웃을 담당하는 <code>layout.ejs</code> 파일을 📁layout 폴더 안에 만들어준다.\n이 <code>layout.ejs</code> 파일이 블로그의 뼈대 역할을 해줄 것이다.\n\n### 4. 부분 렌더링 파츠별로 작성\n📁layout 폴더 안에 각 부분별 파츠가 들어갈📁_partial 폴더를 만들어주고, <code>layout.ejs</code> 파일을 한번 보자.\n\n### 5. 레이아웃 변수를 담당할 _config.yml 파일 작성\nejs 문법 속에 동적으로 들어갈 변수들을 yml 로 작성한다.\n\n### 6. 부가적인 것\n> 서버 통신이 필요한 무언가를 만들고 싶다.. 가령 댓글이라거나..\n\nHexo가 직접 댓글서비스를 지원하진 않지만, 관련 플러그인을 지원한다.\n댓글을 붙이고 싶다면, 상세한 커스터마이징 없이 <a href=\"https://utteranc.es/\">Utterances</a>나 <a href=\"https://help.disqus.com/en/\">Disqus</a>처럼 댓글 위젯을 서비스받는 방법도 있다. Hexo 에서 직접 추천하는 방법이며, 공식 메뉴얼도 있다!\n\n직접 만들고 싶다면, 아쉽게도 Hexo는 정적 서비스를 중점적으로 빠르게 작성하기 위한 프레임워크이기 때문에, 서버통신이 필요한 무언가를 작성할 때 그렇게 용이하지는 않다. 이렇게 되면.. 정적 소스 폴더 안의 js로 직접 서버 API로 ajax를 날리는 방법을 택해야💦..\n\n이럴 바에야 차라리 서버사이드 렌더링(SSR) 방식으로 만드는 게 더 낫지 않은가 고민해보길 바란다. \n\n그래도 Hexo 블로그에 서버 API를 이용하는 덧글 위젯을 직접 만들고 싶다면... <a href=\"#\">[링크]:Hexo 와 API 서버 간의 통신</a>\n\n> iframe 으로 위젯 만들기?\n\niframe 내부에 들어갈 위젯이 고정 높이폭과 너비를 가진다면 가능하다!\n혹은 position: absolute; 로 동동 떠 있으면 iframe으로 위젯을 만들어도 좋다.\n\n\n","tags":["hexo"],"categories":["Framework","Hexo"]},{"title":"Docker 명령어 정리","url":"/post/clgyf00n50009685o6vo748i9/","content":"\n![titleimg](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Docker_%28container_engine%29_logo.svg/1200px-Docker_%28container_engine%29_logo.svg.png)\n\n도커를 한번 써 보니 생각보다 서버를 운영하는 데 편리하고 컨테이너 단위 관리가 용이해서, 이를 잊어버리는 일이 없도록 실행부터 가동 중지까지, 방법을 정리하려고 한다.\n\n### 1. 서버 이미지 만들기\n\n서버 구축 후, 프로젝트 폴더를 Shift + 우클릭하여 cmd(명령 프롬프트 창) 실행\n\nDocker Desktop 이 설치되어있고, 가동시켜서 현재 서비스가 돌아가고 있다는 전제 하에 아래의 명령어를 입력\n\n```\ndocker build -t [생성할 이미지명] .\n```\n\n생성할 이미지명 예시 : ex) MyContainer\n\n온점까지 제대로 입력해야한다.\n해당 명령어를 실행하면, 도커가 프로젝트의 Dockerfile 이 제대로 작성되었다는 가정하에 Dockerfile 내부의 명령어를 실행시켜 컨테이너를 구축한다. 실행 예시는 다음 링크를 참조 <a href=\"https://hexo.io\">[링크]:도커파일 작성하기(Node.js Express)</a>\n\n### 2. 이미지 실행하기\n이미지를 빌드해서 생성했으면, 이제 컨테이너화하여 서버를 운영할 수 있다.\n\n> 1) Docker Desktop 가동\n> 2) 좌측의 Images 에 지정했던 이미지명 찾기\n> 3) RUN 을 통해 가동 (세부설정은 Optional Settings를 통해 설정할 수 있다. 컨테이너명과 Port 등을 지정할 수 있다.)\n> 4) 성공적으로 가동하면 왼측 Containers/Apps 의 컨테이너 목록란에 초록색 컨테이너 박스로 표기된다.\n\n+) 만약 Dockerfile 등의 결함이 있거나 하면 shell 실행이 중지되는데,\n![containericon](/img/postimg/container_disable.png)\n요로코롬 컨테이너 아이콘이 회색으로 표기된다.\n클릭을 통해 해당 로그란을 확인할 수 있다.\n이 경우에는 파일 빌드 자체에 오류가 있는 경우이므로 이미지를 재빌드해야만 한다.\n\n### 3. 컨테이너 실행 확인\n도커 위에서 돌아가고 있는 이미지 컨테이너를 확인해 보자.\n![containericon](/img/postimg/container_correct.png)\n정상적으로 돌아가고 있다면 컨테이너 박스가 녹색으로 표기된다.\n필자는 웹서버이므로 웹 연결을 통해 컨테이너가 해당 로컬 포트를 통해 돌아가고 있는 것을 확인하였다.\n이미지 가동 시 포트를 따로 뚫어 뒀다면 포트포워딩을 통해 포팅하고있는 컴퓨터의 외부 접속도 가능하다.\n\n### 4. 컨테이너 중지\n\n![containericon](/img/postimg/active_server_delete.png)\n> 위 그림처럼 Docker Desktop의 Container/Apps 목록에서 컨테이너를 Delete 한다.\n\n서버에 대한 이미지는 기존에 작성해 놓았기 때문에 컨테이너를 삭제해도 무방하다!\n재가동시킬 땐 이미지를 다시 가동시키면 되니깐..\n\n### 5. 그 외 명령어들\n\n>파일 접근하기 \n\n+) 서버가 돌아갈때 로그 등을 생성하도록 해두었다면, 현재 돌아가고 있는 컨테이너의 내부 파일에 접근하는 것도 가능하다.\n\n```\n docker cp [컨테이너명]:[접근할 파일 경로] [저장할 경로명]\n```\n\n컨테이너명 예시 : ex) MyConatiner\n접근할 파일 경로 예시 : ex)/root/etc/logs\n파일을 저장할 경로명 예시: ex) C:\\Users\\Desktop\\Server_Container_Logs\n\n위 커맨드를 실행하면 서버 내부의 로그파일을 빼낼 수 있다!\n\n>컨테이너 내부 시간대 맞추기\n\n+) 이미지 가동 시 옵셔널 세팅에 포함되지 않은 기능이다.. ㅡ.ㅡ 왜 이렇게 해놓았을까..?\n 다소 곤란한 감이 있지만 이 경우도 명령어로 제어가 가능하다.\n 컨테이너 가동 시에 시간대를 국제시간대로 맞춰주면 된다.\n\n```\n docker run --name [컨테이너명] -p [로컬로 접근할 포트명]:[컨테이너 내부로 뜷어놓을 포트명]\n -e TZ=Asia/Seoul [이미지명]\n```\n\n 이런 식으로 가동하면 -e 커맨드를 통해 이미지 컨테이너의 시간대가 서울로 설정되어 가동된다.","tags":["hexo","docker"],"categories":["CI/CD","Docker"]}]
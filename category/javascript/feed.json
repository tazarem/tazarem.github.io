{
    "version": "https://jsonfeed.org/version/1",
    "title": "Coding Coconut • All posts by \"javascript\" category",
    "description": "주니어 웹 프론트엔드/백엔드 개발자. \\n  공부하는 것도, 노는 것도 그만큼 좋아합니다. \\n 현 직장에서는 AWS Lambda 와 Typscript 를 접목한 서드파티 모듈 개발을 하고 있습니다.",
    "home_page_url": "https://coding-coconut.com",
    "items": [
        {
            "id": "https://coding-coconut.com/post/cluwfj5nb000owc5oeom52klv/",
            "url": "https://coding-coconut.com/post/cluwfj5nb000owc5oeom52klv/",
            "title": "pm2와 클러스터화",
            "date_published": "2022-05-20T07:51:12.000Z",
            "content_html": "<h2 id=\"클러스터화-가동-설정-및-디버깅\"><a href=\"#클러스터화-가동-설정-및-디버깅\" class=\"headerlink\" title=\"클러스터화 가동 설정 및 디버깅\"></a>클러스터화 가동 설정 및 디버깅</h2><p>Node.js의 루트 바로 아래에 있는 인덱스 파일들은 package.json 설정 등을 통하면 멀티스레드로 실행할 수 있다.</p>\n<blockquote>\n<p>package.json 파일 설정과 pm2를 이용하여 별개의 프로그램을 클러스터화 가동한다.</p>\n</blockquote>\n<h3 id=\"1-pm2-npm-모듈-글로벌-옵션으로-깔기-클러스터-작동-확인을-위한-도구\"><a href=\"#1-pm2-npm-모듈-글로벌-옵션으로-깔기-클러스터-작동-확인을-위한-도구\" class=\"headerlink\" title=\"1. pm2 npm 모듈 글로벌 옵션으로 깔기(클러스터 작동 확인을 위한 도구)\"></a>1. pm2 npm 모듈 글로벌 옵션으로 깔기(클러스터 작동 확인을 위한 도구)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pm2 -g</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-클러스터화-파일-작성\"><a href=\"#2-클러스터화-파일-작성\" class=\"headerlink\" title=\"2. 클러스터화 파일 작성\"></a>2. 클러스터화 파일 작성</h3><p>  각 클러스터의 dev 실행 명령어 지정 및 클러스터화 시동 명령어 지정(package.json)</p>\n<blockquote>\n<p>package.json 작성 예제. daum/blog/post는 각기 실행할 별개의 index.ts파일이라고 보면 됨.</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;:&#123;</span><br><span class=\"line\">    &quot;start:cluster&quot;: &quot;pm2-runtime pm2.config.js&quot;,</span><br><span class=\"line\">    &quot;dev:post&quot;: &quot;nodemon --legacy-watch --watch ./ --exec &#x27;npx&#x27; ts-node -r tsconfig-paths/register ./src/post.ts&quot;,</span><br><span class=\"line\">    &quot;dev:blog&quot;: &quot;nodemon --legacy-watch --watch ./ --exec &#x27;npx&#x27; ts-node -r tsconfig-paths/register ./src/blog.ts&quot;,</span><br><span class=\"line\">    &quot;dev:daum&quot;: &quot;nodemon --legacy-watch --watch ./ --exec &#x27;npx&#x27; ts-node -r tsconfig-paths/register ./src/daum.ts&quot;,</span><br><span class=\"line\">    &quot;dev&quot;: &quot;npm run dev:blog &amp; npm run dev:daum &amp; npm run dev:post&quot;,</span><br><span class=\"line\">    &quot;build&quot;: &quot;tsc -p tsconfig.json &amp;&amp; tsc-alias&quot;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>pm2.config.js 작성 예제. 클러스터화를 할 설정파일들을 지정한다. 인스턴스 갯수만큼 생성이 됨.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports=&#123;</span><br><span class=\"line\">    apps:[</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;post&quot;</span>, <span class=\"attr\">script</span>: <span class=\"string\">&quot;./dist/post.js&quot;</span>, <span class=\"attr\">instances</span>: <span class=\"number\">1</span>, <span class=\"attr\">exec_mode</span>: <span class=\"string\">&quot;cluster&quot;</span> &#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;blog&quot;</span>, <span class=\"attr\">script</span>: <span class=\"string\">&quot;./dist/blog.js&quot;</span>, <span class=\"attr\">instances</span>: <span class=\"number\">1</span>, <span class=\"attr\">exec_mode</span>: <span class=\"string\">&quot;cluster&quot;</span> &#125;,</span><br><span class=\"line\">        &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;daum&quot;</span>, <span class=\"attr\">script</span>: <span class=\"string\">&quot;./dist/daum.js&quot;</span>, <span class=\"attr\">instances</span>: <span class=\"number\">1</span>, <span class=\"attr\">exec_mode</span>: <span class=\"string\">&quot;cluster&quot;</span> &#125;,</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-빌드하기\"><a href=\"#3-빌드하기\" class=\"headerlink\" title=\"3. 빌드하기\"></a>3. 빌드하기</h3><blockquote>\n<p>타입스크립트 파일들이 js로 빌드된다.</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-클러스터-가동\"><a href=\"#4-클러스터-가동\" class=\"headerlink\" title=\"4. 클러스터 가동\"></a>4. 클러스터 가동</h3><blockquote>\n<p>package.json에서 선제 명령어 설정을 해줘야 함</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run start:cluster</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-이후-디버깅은-pm2-에서-할-수-있음\"><a href=\"#5-이후-디버깅은-pm2-에서-할-수-있음\" class=\"headerlink\" title=\"5. 이후 디버깅은 pm2 에서 할 수 있음\"></a>5. 이후 디버깅은 pm2 에서 할 수 있음</h3><blockquote>\n<p>가동되고 있는 클러스터 확인</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 list</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>클러스터 상세내역 확인(방향키로 조정)</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 monit</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>클러스터 가동 취소</p>\n</blockquote>\n<p>npm run start:cluster 명령어를 쳤던 커맨드창 ctrl+c </p>\n<p>이렇게 취소하면 pm2 list 했을 때 생성되었던 클러스터들이 사라진 것을 볼 수 있다.</p>\n",
            "tags": [
                "pm2"
            ]
        },
        {
            "id": "https://coding-coconut.com/post/cluwfj5nk0045wc5o1ld53db5/",
            "url": "https://coding-coconut.com/post/cluwfj5nk0045wc5o1ld53db5/",
            "title": "함수의 비동기화와 async 키워드",
            "date_published": "2022-01-27T00:56:15.000Z",
            "content_html": "<h1 id=\"함수의-비동기화\"><a href=\"#함수의-비동기화\" class=\"headerlink\" title=\"함수의 비동기화\"></a>함수의 비동기화</h1><p>기존 async await 를 단순히 비동기를 순차적으로 처리하는 데에만 이용하다가,<br>실무상 비동기로 함수를 처리해야 할 일이 생겼다.</p>\n<blockquote>\n<p>일반적인 자바스크립트 함수</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//그냥 함수</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자바스크립트 특성상 비동기 함수의 경우 일반 함수에서 호출 시 실행하라는 오더만 내리고 바로 다음 항목을 진행한다.</p>\n<blockquote>\n<p>비동기를 동기적으로 처리할 때, async await 의 사용법.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">somePromiseFunc</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//Promise 반환 함수인 somePromiseFunc.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//input do something..</span></span><br><span class=\"line\">         resolve(async_logic_result)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">         reject(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//async await 의 일반적인 사용.</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> somePromiseFunc() <span class=\"comment\">//비동기 함수의 응답을 받기 위해 await를 사용</span></span><br><span class=\"line\">    <span class=\"comment\">//do other func</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>async await 는 비동기 처리함수를 동기적으로 처리할 때 쓰이는 문법이다.<br>await는 async를 선언한 함수 내부에서만 쓸 수 있으며, Promise 를 반환하는 함수에 써서 result 변수에 resolve 내부에 들어가있는 결과값을 받을 수 있다.</p>\n<p>평소에 이렇게 비동기를 동기적으로 수행처리하는 과정만 생각하는게 주인데, 이번에는 업무상 응답속도를 줄이기 위해 의도적으로 함수를 비동기화해야하는 것이었다.</p>\n<blockquote>\n<p>실무에선 300줄 이상의 무거운 쿼리는 수행하라는 명령만 내리고, 문자열처럼 생성이 빠른 것들은 빨리 생성해서 바로 200 응답을 전송하길 원했다.</p>\n</blockquote>\n<p>이 방법을 찾는 과정에서 각 실행 방법의 응답속도를 비교했고, 더불어<br>async-await 키워드의 새로운 기능을 알게 되었다.</p>\n<br>\n\n<h1 id=\"속도-비교\"><a href=\"#속도-비교\" class=\"headerlink\" title=\"속도 비교\"></a>속도 비교</h1><h2 id=\"1-일반-실행\"><a href=\"#1-일반-실행\" class=\"headerlink\" title=\"1. 일반 실행\"></a>1. 일반 실행</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someHeavyFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//무거운 쿼리 로직. query를 때릴 때 사용하는 모듈 자체는 비동기식으로 작동한다.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callAsyncFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_key = otherModule.keyMaker(someInput); <span class=\"comment\">//빠른 실행이 가능한 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    someHeavyFunc()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_answer=&#123;</span><br><span class=\"line\">        key:fast_key</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fast_answer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>javascript는 기본적으로 비동기로 작동한다고 하지 않았었나..? 하지만 Postman과 console.log로 각 함수 실행과정과 응답속도를 테스트한 결과, 200 응답 뒤에 무거운 함수가 실행되는 경우는 없었다.</p>\n<p><img src=\"/img/postimg/default_do.png\" alt=\"default_do\"><br>거진.. 요청당 약 1초가 걸린다. 어마무시하다.</p>\n<h2 id=\"2-setTimeout-함수\"><a href=\"#2-setTimeout-함수\" class=\"headerlink\" title=\"2. setTimeout 함수\"></a>2. setTimeout 함수</h2><p>두 번째로는 비동기 함수의 개념을 배울 때 주로 사용하는 setTimeout으로 테스트하였다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someHeavyFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//무거운 쿼리 로직..</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callAsyncFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_key = otherModule.keyMaker(someInput); <span class=\"comment\">//빠른 실행이 가능한 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        someHeavyFunc()</span><br><span class=\"line\">    &#125;,<span class=\"number\">50</span>) <span class=\"comment\">//비동기 처리를 위해서는 어쩔 수 없나...? 근데 진짜 이렇게?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_answer=&#123;</span><br><span class=\"line\">        key:fast_key</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fast_answer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>async 키워드를 함수 앞에 붙인다는 게 무슨 뜻인지 제대로 알지 못해서 생긴 폐해다(…)</p>\n<p><img src=\"/img/postimg/settimeout_do.png\" alt=\"settimeout_do\"><br>응답속도가 많이 줄었다. setTimeOut 함수가 비동기 함수인 걸 알고 return을 먼저 보내고 무거운 함수를 실행한 것이다. 속도 개선은 되었지만, 당연스럽게도 setTimeOut함수를 사용하면 초반지연이 발생한다.</p>\n<p>앞서 실험했던 일반 실행과 비교해봤을 때, 이는 js가 봤을 때 함수가 비동기임을 몰라서 생기는 상황인 것 같았다.</p>\n<ul>\n<li>그러면 어떻게 비동기 함수인걸 알려줘야할까?</li>\n</ul>\n<p>답은 async-await 페어 중 async에 있었다.</p>\n<h2 id=\"3-async-키워드\"><a href=\"#3-async-키워드\" class=\"headerlink\" title=\"3. async 키워드\"></a>3. async 키워드</h2><blockquote>\n<p>async 키워드는 함수를 비동기 취급한다.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someHeavyFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//무거운 쿼리 로직..</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callAsyncFunc</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_key = otherModule.keyMaker(someInput); <span class=\"comment\">//빠른 실행이 가능한 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    someHeavyFunc()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> fast_answer=&#123;</span><br><span class=\"line\">        key:fast_key</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fast_answer</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>무거운 함수 앞에 async를 붙이고, 무거운 함수를 호출하는 함수는 async 키워드를 붙이지 않는다.<br>async 키워드를 붙이지 않았으니, await도 쓸 수 없다.<br>결과는 어떨까?</p>\n<p><img src=\"/img/postimg/async_do.png\" alt=\"async_do\"></p>\n<p>성공이다! 원하는 응답도 제대로 가져온다.</p>\n<h1 id=\"응용\"><a href=\"#응용\" class=\"headerlink\" title=\"응용\"></a>응용</h1><p>… 그러면 특정 부분은 비동기로 수행하고 비동기 함수끼리는 동기적으로 처리하고 싶을 때, 이렇게 하면 된다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">caller</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//caller는 일반 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> faster = doMakeFaster() <span class=\"comment\">//일반 함수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAsync</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//비동기로 묶어서 처리할 랩퍼를 선언</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> result1= <span class=\"keyword\">await</span> someAsyncFunc() <span class=\"comment\">//비동기 함수를 순차적으로 시행</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> someAsyncFunc2(result1) <span class=\"comment\">//비동기 함수를 순차적으로 시행</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    doAsync() <span class=\"comment\">//비동기로 시행</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> faster;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>faster 먼저 변수에 결과값이 담기고, doAsync()는 명령만 내린 뒤 바로 return 값을 반환한다. 이후 doAsync() 함수 수행 명령을 내린 시점에서 someAsyncFunc()와 someAsyncFunc2가 순차적으로 실행된다.</p>\n<p>비동기 처리를 동기적으로 수행하기 위해 여태껏 await에만 초점을 맞추고 있었는데, 이번엔 await를 사용하지 않고 async만 사용해 보았다.<br>async-await는 기본적으로 페어지만, 함수를 비동기로 실행할 때도 있는 법이다.<br>두 키워드를 좀더 제대로 알게 된 것 같아 기쁘다. 유익한 경험이었다.</p>\n",
            "tags": [
                "비동기",
                "asyncawait",
                "postman",
                "속도 개선"
            ]
        }
    ]
}